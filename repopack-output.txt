This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-26T00:47:27.896Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
EdiSource.App/
  Loops/
    _834.cs
    Loop2000.cs
    Loop2100.cs
  Segments/
    Loop2000_DTP.cs
    Loop2000_INS.cs
    Loop2000_REF.cs
    Loop2100_NM1.cs
    TS_DTP.cs
    TS_REF.cs
    TS_SE.cs
    TS_ST.cs
  EdiSource.App.csproj
  Program.cs
EdiSource.Domain/
  Elements/
    Element.cs
    Element.Equality.cs
    Element.IList.cs
    ElementExtensions.cs
  Exceptions/
    DataElementParsingError.cs
    EdiReaderException.cs
    ProbableCircularReferenceException.cs
  Helper/
    PrettyPrinting/
      ILoopPrinter.cs
      LoopPrinter.cs
    EnumExtensions.cs
    GeneralExtensions.cs
    ParentHelpers.cs
  Identifiers/
    EdiId.cs
    IEdi.cs
    IEdiId.cs
    ISegmentIdentifier.cs
    SegmentFactory.cs
  IO/
    EdiReader/
      EdiReader.cs
      IEdiReader.cs
    Parser/
      EdiParser.cs
      IEdiParser.cs
    Serializer/
      EdiSerializer.WriteToFile.cs
      EdiSerializer.WriteToPrettyString.cs
      EdiSerializer.WriteToStream.cs
      EdiSerializer.WriteToString.cs
      IEdiSerializer.cs
  Loop/
    Extensions/
      LoopExtensions.ActOnElementOfType.cs
      LoopExtensions.EdiAction.cs
      LoopExtensions.FindEdiElement.cs
      LoopExtensions.FindParent.cs
      LoopExtensions.GetRoot.cs
      LoopExtensions.SegmentAction.cs
      LoopExtensions.YieldChildLoops.cs
      LoopExtensions.YieldChildSegments.cs
    ILoop.cs
    ILoopInitialize.cs
    LoopList.cs
  Segments/
    Extensions/
      SegmentExtensions.Bool.cs
      SegmentExtensions.DateOnly.cs
      SegmentExtensions.DateTime.cs
      SegmentExtensions.Decimal.cs
      SegmentExtensions.Enum.cs
      SegmentExtensions.Int.cs
      SegmentExtensions.TimeOnly.cs
      SegmentExtensions.WriteToStringBuilder.cs
    Segment.cs
    Segment.Equality.cs
    SegmentList.cs
  Separator/
    Separators.CreateISA.cs
    Separators.cs
  Standard/
    Date/
      DateFormats.cs
    Loops/
      ISA/
        CommunicationIdType.cs
        CommunicationIdTypeExtensions.cs
        IdentificationCode.cs
        InterchangeEnvelope.cs
      FunctionalGroup.cs
      ITransactionSet.cs
      TransactionSetDefinition.cs
    Segments/
      DTPData/
        DateFormatCode.cs
        DateFormatMapper.cs
        DTP.cs
      STData/
        ST.cs
        TransactionSetIdentifierCode.cs
      GE.cs
      GenericSegment.cs
      GS.cs
      IEA.cs
      IRefresh.cs
      ISA.cs
      REF.cs
      SE.cs
  Structure/
    GenericTransactionSetData/
      Generic_SE.cs
      Generic_ST.cs
      GenericTransactionSet.cs
    BasicEdi.cs
    EdiTree.Create.cs
    EdiTree.cs
  Validation/
    Data/
      EdiValidationResult.cs
      IIndirectValidatable.cs
      ISourceGeneratorValidatable.cs
      IValidatable.cs
      ValidationMessage.cs
      ValidationMessage.Extensions.cs
      ValidationMessageTablePrinter.cs
      ValidationSeverity.cs
      ValidationSubject.cs
    Factory/
      ValidationFactory.Loop.cs
      ValidationFactory.Segment.cs
    IO/
      IValidationMessageCsvConverter.cs
      ValidationMessageCsvConverter.cs
    SourceGeneration/
      BeDateAttribute.cs
      BeDateTimeAttribute.cs
      BeDecimalAttribute.cs
      BeIntAttribute.cs
      BeTime.cs
      CompositeElementLengthAttribute.cs
      ElementLengthAttribute.cs
      EmptyAttribute.cs
      IsOneOfValuesAttribute.cs
      NotEmptyAttribute.cs
      NotOneOfValuesAttribute.cs
      RequiredDataElements.cs
      RequiredElement.cs
    Validator/
      IValidateEdi.cs
      ValidateEdi.cs
      ValidationHelper.cs
  EdiCommon.cs
  EdiSource.Domain.csproj
  GlobalUsings.cs
EdiSource.Domain.Tests/
  Segments/
    SegmentTests.cs
  EdiSource.Domain.Tests.csproj
  UnitTest1.cs
EdiSource.Generator/
  EdiSource.Generator/
    Helper/
      CodeWriter.cs
      Constants.cs
      HelperFunctions.cs
    LoopGen/
      Data/
        Attributes.cs
        LoopMeta.cs
      GeneratorWithAttributeHelper.cs
      LoopGenerator.ChannelConstructorGenerator.cs
      LoopGenerator.cs
      LoopGenerator.EdiElementGenerator.cs
      LoopGenerator.ImplementationGenerator.cs
      LoopGenerator.QueueConstructorGenerator.cs
      LoopGenerator.TransactionSetGenerator.cs
    Properties/
      launchSettings.json
    SegmentGen/
      SegmentGenerator.Generate.cs
      SegmentsGenerator.cs
    ValidationGen/
      ValidationGenerator.cs
    EdiSource.Generator.csproj
    GlobalUsings.cs
SourceGenerators1/
  EdiSource.Generator.Tests/
    LoopGenerator/
      LoopGeneratorTests.cs
      LoopGeneratorTests.IsTranscationSet#TransactionSet.ChannelConstructor.g.verified.cs
      LoopGeneratorTests.IsTranscationSet#TransactionSet.EdiElement.g.verified.cs
      LoopGeneratorTests.IsTranscationSet#TransactionSet.Implementation.g.verified.cs
      LoopGeneratorTests.IsTranscationSet#TransactionSet.TransactionSet.g.verified.cs
      LoopGeneratorTests.TestA#TransactionSet.ChannelConstructor.g.verified.cs
      LoopGeneratorTests.TestA#TransactionSet.EdiElement.g.verified.cs
      LoopGeneratorTests.TestA#TransactionSet.Implementation.g.verified.cs
    SegmentGenerator/
      SegmentGeneratorTests.cs
      SegmentGeneratorTests.TestA#Test_INS.Implementation.g.verified.cs
    Utils/
      ModuleInitializer.cs
      TestHelperFunctions.cs
    ValidationTests/
      ValidationGeneratorTests.cs
      ValidationGeneratorTests.TestA#TS_SE.Validation.g.received.cs
    EdiSource.Generator.Tests.csproj
.gitignore
.repopackignore
EdiSource.sln
repopack.config.json

================================================================
Repository Files
================================================================

================
File: EdiSource.App/Loops/_834.cs
================
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Standard.Loops;
using EdiSource.Domain.Standard.Segments;
using EdiSource.Domain.Standard.Segments.STData;
using EdiSource.Segments;

namespace EdiSource.Loops;

[LoopGenerator<FunctionalGroup, _834, TS_ST>]
public sealed partial class _834 : ITransactionSet<_834>
{
    [SegmentHeader] public TS_ST ST { get; set; } = default!;

    [SegmentList] public SegmentList<TS_REF> REFs { get; set; } = [];

    [Segment] public TS_DTP? DTP { get; set; }

    [Loop] public Loop2000 Loop2000 { get; set; } = default!;

    [LoopList] public LoopList<Loop2100> Loop2100s { get; set; } = [];

    [SegmentFooter] public TS_SE SE { get; set; } = default!;

    public static TransactionSetDefinition Definition { get; } =
        TransactionSetDefinitionsFactory<_834>.CreateDefinition();
}

================
File: EdiSource.App/Loops/Loop2000.cs
================
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;
using EdiSource.Segments;

namespace EdiSource.Loops;

[LoopGenerator<_834, Loop2000, Loop2000_INS>]
public partial class Loop2000 : IValidatable
{
    [SegmentHeader] public Loop2000_INS INS { get; set; } = default!;

    public IEnumerable<ValidationMessage> Validate()
    {
        yield return ValidationFactory.Create(this, ValidationSeverity.Warning, "Nof");
    }
}

================
File: EdiSource.App/Loops/Loop2100.cs
================
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using EdiSource.Segments;

namespace EdiSource.Loops;

[LoopGenerator<_834, Loop2100, Loop2100_NM1>]
public partial class Loop2100 : IValidatable
{
    [SegmentHeader] public Loop2100_NM1 NM1 { get; set; } = default!;

    public IEnumerable<ValidationMessage> Validate()
    {
        return [];
    }
}

================
File: EdiSource.App/Segments/Loop2000_DTP.cs
================
using EdiSource.Domain.SourceGeneration;
using EdiSource.Loops;

namespace EdiSource.Segments;

[SegmentGenerator<Loop2000>("DTP")]
public partial class Loop2000_DTP;

================
File: EdiSource.App/Segments/Loop2000_INS.cs
================
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Loops;

namespace EdiSource.Segments;

[BeDate(ValidationSeverity.Critical, 2, 0)]
[SegmentGenerator<Loop2000>("INS")]
public partial class Loop2000_INS;

================
File: EdiSource.App/Segments/Loop2000_REF.cs
================
using EdiSource.Domain.SourceGeneration;
using EdiSource.Loops;

namespace EdiSource.Segments;

[SegmentGenerator<Loop2000>("REF")]
public partial class Loop2000_REF;

================
File: EdiSource.App/Segments/Loop2100_NM1.cs
================
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;
using EdiSource.Loops;

namespace EdiSource.Segments;

[SegmentGenerator<Loop2100>("NM1")]
public partial class Loop2100_NM1 : IValidatable
{
    public IEnumerable<ValidationMessage> Validate()
    {
        yield return ValidationFactory.Create(this, ValidationSeverity.Warning, "WTF");
    }
}

================
File: EdiSource.App/Segments/TS_DTP.cs
================
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Standard.Segments.DTPData;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Loops;

namespace EdiSource.Segments;

[ElementLength(ValidationSeverity.Critical, 0, 20)]
[SegmentGenerator<_834, DTP>("DTP")]
public partial class TS_DTP;

================
File: EdiSource.App/Segments/TS_REF.cs
================
using EdiSource.Domain.SourceGeneration;
using EdiSource.Loops;

namespace EdiSource.Segments;

[SegmentGenerator<_834>("REF")]
public partial class TS_REF;

================
File: EdiSource.App/Segments/TS_SE.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Standard.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Loops;

namespace EdiSource.Segments;

public class TS_SE : SE<_834>, ISegmentIdentifier<TS_SE>
{
    public override _834? Parent { get; set; }
    public static EdiId EdiId { get; } = new("SE");
}

================
File: EdiSource.App/Segments/TS_ST.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Standard.Loops;
using EdiSource.Domain.Standard.Segments.STData;
using EdiSource.Loops;

namespace EdiSource.Segments;

public class TS_ST : ST<_834>, ISegmentIdentifier<TS_ST>
{
    public override _834? Parent { get; set; }

    public static EdiId EdiId { get; } = new("ST", "834");
}

================
File: EdiSource.App/EdiSource.App.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <RootNamespace>EdiSource</RootNamespace>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\EdiSource.Domain\EdiSource.Domain.csproj"/>
        <ProjectReference Include="..\EdiSource.Generator\EdiSource.Generator\EdiSource.Generator.csproj"
                          OutputItemType="Analyzer"
                          ReferenceOutputAssembly="false"/>
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Dumpify" Version="0.6.6"/>
    </ItemGroup>
</Project>

================
File: EdiSource.App/Program.cs
================
using EdiSource.Domain;
using EdiSource.Domain.Identifiers;using EdiSource.Domain.IO.Parser;
using EdiSource.Domain.Standard.Loops.ISA;
using EdiSource.Domain.Validation.Data;
using EdiSource.Loops;

var input =
    """
    ISA*i0*          *00*          *ZZ*SENDER         *ZZ*RECEIVER       *200901*1319*^*00501*000000905*0*P*:~
    GS*09*343*343*333*343*3*3*3*34~
    ST*834*ABCD~
    REF*A~
    REF*B~
    DTP*1*D8*2024e0106~
    INS*A~
    NM1*1~
    NM1*2~
    SE*123~
    GE*0*098~
    IEA*1*123~
    """;
;
//;

var ediId = new EdiId("NO");

var j = (await EdiCommon.ParseIntoSegments(input)).ToArray();
var isa = j[0];
var k = isa.ToString();

var jjj = ediId.MatchesSegment(isa);


InterchangeEnvelope.TransactionSetDefinitions.Add(_834.Definition);

var env = await EdiCommon.ParseEdi<InterchangeEnvelope>(input);

Console.WriteLine(EdiCommon.PrettyPrint(env));

ValidationMessageTablePrinter.PrintColorCodedValidationMessagesTable(EdiCommon.Validate(env));
;

================
File: EdiSource.Domain/Elements/Element.cs
================
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.Elements;

/// <summary>
///     An element presents a data element.
///     A data element is comprised of composite elements, though typically most data elements only contain a single
///     composite element.
///     Because of this, the class contains overloads and implicit typing to allow for easier use.
///     Element element = "20230101";
///     Element element2 = ["20230101", "20240101"];
/// </summary>
/// <param name="values"></param>
public sealed partial class Element(IEnumerable<string>? values = null) : IList<string>
{
    private readonly List<string> _compositeElements = values?.ToList() ?? [];

    public static implicit operator Element(string[] values)
    {
        return new Element(values);
    }

    public static implicit operator Element(string value)
    {
        return new Element([value]);
    }

    public static implicit operator string(Element element)
    {
        return element._compositeElements[0];
    }

    public static implicit operator string[](Element element)
    {
        return element._compositeElements.ToArray();
    }

    /// <summary>
    ///     Create a segment equivalent from segment text
    /// </summary>
    /// <param name="segmentText"></param>
    /// <param name="separators"></param>
    /// <returns></returns>
    public static Element[] FromString(string segmentText, Separators? separators = null)
    {
        separators ??= Separators.DefaultSeparators;

        return segmentText
            .Trim()
            .Trim(separators.SegmentSeparator)
            .Split(separators.DataElementSeparator)
            .Select(x => x.Split(separators.CompositeElementSeparator))
            .Select(x => new Element(x))
            .ToArray();
    }

    /// <summary>
    ///     Creates multiple segment equivalents from segment text
    /// </summary>
    /// <param name="segmentText"></param>
    /// <param name="separators"></param>
    /// <returns></returns>
    public static Element[][] MultipleFromString(string segmentText, Separators? separators = null)
    {
        separators ??= Separators.DefaultSeparators;

        return segmentText
            .Split(separators.SegmentSeparator)
            .Select(x => FromString(segmentText, separators))
            .ToArray();
    }
}

================
File: EdiSource.Domain/Elements/Element.Equality.cs
================
namespace EdiSource.Domain.Elements;

public partial class Element
{
    public override bool Equals(object? obj)
    {
        if (obj is not IList<string> compositeElements) return false;
        if (compositeElements.Count != _compositeElements.Count) return false;

        foreach (var (e, x) in compositeElements.Zip(_compositeElements, (s, s1) => (s, s1)))
            if (!e.Equals(x))
                return false;

        return true;
    }

    public bool Equals(Element other)
    {
        return other._compositeElements.SequenceEqual(_compositeElements);
    }

    public static bool operator ==(Element left, Element right)
    {
        return Equals(left, right);
    }

    public static bool operator !=(Element element1, Element element2)
    {
        return !(element1 == element2);
    }

    public override int GetHashCode()
    {
        return _compositeElements.GetHashCode();
    }
}

================
File: EdiSource.Domain/Elements/Element.IList.cs
================
using System.Collections;

namespace EdiSource.Domain.Elements;

public partial class Element
{
    public IEnumerator<string> GetEnumerator()
    {
        return _compositeElements.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    public void Add(string item)
    {
        _compositeElements.Add(item);
    }

    public void Clear()
    {
        _compositeElements.Clear();
    }

    public bool Contains(string item)
    {
        return _compositeElements.Contains(item);
    }

    public void CopyTo(string[] array, int arrayIndex)
    {
        _compositeElements.CopyTo(array, arrayIndex);
    }

    public bool Remove(string item)
    {
        return _compositeElements.Remove(item);
    }

    public int Count => _compositeElements.Count;
    public bool IsReadOnly => false;

    public int IndexOf(string item)
    {
        return _compositeElements.IndexOf(item);
    }

    public void Insert(int index, string item)
    {
        _compositeElements.Insert(index, item);
    }

    public void RemoveAt(int index)
    {
        _compositeElements.RemoveAt(index);
    }

    public string this[int index]
    {
        get => _compositeElements[index];
        set => _compositeElements[index] = value;
    }
}

================
File: EdiSource.Domain/Elements/ElementExtensions.cs
================
using System.Globalization;

namespace EdiSource.Domain.Elements;

public static class ElementExtensions
{
    /// <summary>
    ///     Attempts to parse a date from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static DateTime? GetDate(this Element it, int compositeElement = 0, string format = "yyyyMMdd")
    {
        var element = it.Count > compositeElement
            ? it[compositeElement]
            : null;

        return element is null
            ? null
            : DateTime.TryParseExact(element, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out var date)
                ? date
                : null;
    }

    /// <summary>
    ///     Attempts to parse an int from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="compositeElement"></param>
    /// <returns></returns>
    public static int? GetInt(this Element it, int compositeElement = 0)
    {
        var element = it.Count > compositeElement
            ? it[compositeElement]
            : null;

        return element is null
            ? null
            : int.TryParse(element, out var value)
                ? value
                : null;
    }

    /// <summary>
    ///     Attempts to parse a decimal from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="compositeElement"></param>
    /// <returns></returns>
    public static decimal? GetDecimal(this Element it, int compositeElement = 0)
    {
        var element = it.Count > compositeElement
            ? it[compositeElement]
            : null;

        return element is null
            ? null
            : decimal.TryParse(element, out var value)
                ? value
                : null;
    }

    /// <summary>
    ///     Attempts to parse a bool from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="trueValue">The value that is expected when true</param>
    /// <param name="compositeElement"></param>
    /// <param name="implicitFalse">
    ///     When true, if element is not trueValue then false.
    ///     When false, if element is not trueValue or falseValue then null
    /// </param>
    /// <param name="falseValue">The value expected when false</param>
    /// <returns></returns>
    public static bool? GetBool(this Element it, string trueValue, int compositeElement = 0, bool implicitFalse = true,
        string falseValue = "N")
    {
        var element = it.Count > compositeElement
            ? it[compositeElement]
            : null;
        return element is null
            ? null
            : element == trueValue
                ? true
                : element == falseValue
                    ? false
                    : implicitFalse
                        ? false
                        : null;
    }

    /// <summary>
    ///     Attempts to parse an enum from an element via enum name.
    ///     If tryAddUnderscore is true, the will also try an enum name with
    ///     an '_' prefix to enable enums that start with not allowed characters.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="compositeElement"></param>
    /// <param name="tryAddUnderscore"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static TEnum? GetEnum<TEnum>(this Element it, int compositeElement = 0, bool tryAddUnderscore = true)
        where TEnum : struct, Enum
    {
        var element = it.Count > compositeElement
            ? it[compositeElement]
            : null;

        return element is null
            ? null
            : Enum.TryParse<TEnum>(element, out var value)
                ? value
                : tryAddUnderscore
                    ? Enum.TryParse($"_{element}", out value)
                        ? value
                        : null
                    : null;
    }

    /// <summary>
    ///     Attempts to parse a DateOnly from element.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static DateOnly? GetDateOnly(this Element it, int compositeElement = 0, string format = "yyyyMMdd")
    {
        var element = it.Count > compositeElement
            ? it[compositeElement]
            : null;

        return element is null
            ? null
            : DateOnly.TryParseExact(element, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out var date)
                ? date
                : null;
    }

    /// <summary>
    ///     Attempts to parse a TimeOnly from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static TimeOnly? GetTimeOnly(this Element it, int compositeElement = 0, string format = "HHmm")
    {
        var element = it.Count > compositeElement
            ? it[compositeElement]
            : null;

        return element is null
            ? null
            : TimeOnly.TryParseExact(element, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out var time)
                ? time
                : null;
    }
}

================
File: EdiSource.Domain/Exceptions/DataElementParsingError.cs
================
namespace EdiSource.Domain.Exceptions;

public sealed class DataElementParsingError(
    int dataElement,
    int compositeElement,
    Type type) : Exception($"Element {dataElement}:{compositeElement} is required to parse {type.Name}");

================
File: EdiSource.Domain/Exceptions/EdiReaderException.cs
================
namespace EdiSource.Domain.Exceptions;

public sealed class EdiReaderException()
    : Exception("No segments were created. " +
                "This indicates that the EDI string is not valid, likely due to misconfigured separators," +
                "or for envelope reading, an improper ISA was supplied ");

================
File: EdiSource.Domain/Exceptions/ProbableCircularReferenceException.cs
================
namespace EdiSource.Domain.Exceptions;

public sealed class ProbableCircularReferenceException(int iterations, int maxIterations)
    : Exception(
        $"Function has iterated {iterations} iterations where max iterations are {maxIterations}, likely a circular reference");

================
File: EdiSource.Domain/Helper/PrettyPrinting/ILoopPrinter.cs
================
namespace EdiSource.Domain.Helper.PrettyPrinting;

public interface ILoopPrinter
{
    /// <summary>
    ///     Appends a line with the current indentation
    /// </summary>
    void AppendLine();

    /// <summary>
    ///     Appends a line with the current indentation with the segment value
    /// </summary>
    /// <param name="segment"></param>
    void AppendLine(string segment);

    /// <summary>
    ///     Appends a line with the loopName and increase indentation
    /// </summary>
    /// <param name="loopName"></param>
    /// <returns></returns>
    IDisposable AppendLoop(string loopName);

    /// <summary>
    ///     Increases the indentation without appending a line
    /// </summary>
    /// <returns></returns>
    IDisposable IndentBlock();

    /// <summary>
    ///     Serializes the content to a string
    /// </summary>
    /// <returns></returns>
    string ToString();
}

================
File: EdiSource.Domain/Helper/PrettyPrinting/LoopPrinter.cs
================
using System.Text;

namespace EdiSource.Domain.Helper.PrettyPrinting;

/// <summary>
///     Used for pretty printing loops and segments
/// </summary>
public sealed class LoopPrinter : ILoopPrinter
{
    private const string Indent =
        "                                                                                                                                ";

    private readonly StringBuilder _builder = new();
    private int _indentLevel;

    public void AppendLine()
    {
        _builder.AppendLine();
    }

    public void AppendLine(string segment)
    {
        _builder.Append(Indent.AsSpan(0, _indentLevel * 4));
        _builder.AppendLine(segment);
    }


    public IDisposable AppendLoop(string loopName)
    {
        if (!string.IsNullOrEmpty(loopName))
        {
            _builder.Append(Indent[..(_indentLevel * 4)]);
            _builder.AppendLine(loopName);
        }
        else
        {
            _builder.AppendLine();
        }

        return new IndentationBlock(this);
    }

    public IDisposable IndentBlock()
    {
        return new IndentationBlock(this);
    }

    public override string ToString()
    {
        return _builder.ToString();
    }

    private class IndentationBlock : IDisposable
    {
        private readonly LoopPrinter _writer;

        public IndentationBlock(LoopPrinter writer)
        {
            _writer = writer;
            _writer._indentLevel++;
        }

        public void Dispose()
        {
            _writer._indentLevel--;
        }
    }
}

================
File: EdiSource.Domain/Helper/EnumExtensions.cs
================
namespace EdiSource.Domain.Helper;

public static class EnumExtensions
{
    private static readonly Dictionary<Type, string[]> EnumLookup = new();

    public static string[] EnumToStringArray<T>(bool removeUnderscoreFromStart = true) where T : Enum
    {
        var type = typeof(T);

        return EnumLookup.TryGetValue(type, out var result)
            ? result
            : EnumLookup[type] = Enum.GetValues(typeof(T))
                .Cast<T>()
                .Select(code => code
                    .ToString()
                    .ApplyIf(x => x.TrimStart('_', ' '), removeUnderscoreFromStart))
                .ToArray();
    }
}

================
File: EdiSource.Domain/Helper/GeneralExtensions.cs
================
namespace EdiSource.Domain.Helper;

internal static class GeneralExtensions
{
    public static TR Map<T, TR>(this T it, Func<T, TR> fun)
    {
        return fun(it);
    }

    public static T ApplyIf<T>(this T it, Func<T, T> fun, bool condition)
    {
        return condition ? fun(it) : it;
    }

    public static T Do<T>(this T it, Action<T> action)
    {
        action(it);
        return it;
    }
    
    public static T DoIf<T>(this T it, Action<T> action, bool condition)
    {
        if (condition) return it;

        action(it);
        return it;
    }

    public static T? DoIfNotNull<T>(this T? it, Action<T> action)
    {
        if (it is null) return default;

        action(it);
        return it;
    }
    
    public static T? DoIfNull<T>(this T? it, Action action)
    {
        if (it is not null) return default;

        action();
        return it;
    }

    public static Task<TR> MapAsync<T, TR>(this T it, Func<T, Task<TR>> fun)
    {
        return fun(it);
    }

    public static async Task<T> DoAsync<T>(this T it, Func<T, Task> action)
    {
        await action(it);
        return it;
    }


    public static bool InsideBounds<T>(this IList<T> it, int elementIndex)
    {
        return elementIndex < it.Count && elementIndex >= 0;
    }

    public static bool InsideBoundsTiered<T>(this IList<IList<T>> it, int first, int second)
    {
        return it.InsideBounds(first) && it[first].InsideBounds(second);
    }

    public static bool InsideBounds<T>(this T[] it, int elementIndex)
    {
        return elementIndex < it.Length && elementIndex >= 0;
    }

    public static bool InsideBoundsTiered<T>(this T[][] it, int first, int second)
    {
        return it.InsideBounds(first) && it[first].InsideBounds(second);
    }
}

================
File: EdiSource.Domain/Helper/ParentHelpers.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;

namespace EdiSource.Domain.Helper;

public static class ParentHelpers
{
    public static ILoop? GetParentGeneric<T>(this T edi) where T : IEdi
    {
        return edi is IEdi<T> e ? (ILoop?)e.Parent : null;
    }
}

================
File: EdiSource.Domain/Identifiers/EdiId.cs
================
using System.Text;
using EdiSource.Domain.Elements;
using EdiSource.Domain.Segments;

namespace EdiSource.Domain.Identifiers;

/// <summary>
///     Represents an ID of a segment.
///     If a value in the elements is null, it is ignored for matching.
/// </summary>
/// <param name="ids"></param>
public readonly struct EdiId(params Element?[] ids)
{
    private Element?[] Ids { get; } = ids;

    public bool MatchesSegment(Segment segment)
    {
        for (var deI = 0; deI < Ids.Length; deI++)
        {
            var de = Ids[deI];
            if (de is null) continue;

            for (var ceI = 0; ceI < de.Count; ceI++)
            {
                var ce = de[ceI];

                if (segment.GetCompositeElementOrNull(deI, ceI) is not { } value || value != ce)
                    return false;
            }
        }

        return true;
    }

    public bool MatchesEdiId(EdiId other)
    {
        if (Ids.Length != other.Ids.Length) return false;

        for (var deI = 0; deI < Ids.Length; deI++)
        {
            var de = Ids[deI];
            var deOther = other.Ids[deI];

            if (de is null && deOther is null) continue;
            if (de is null || deOther is null) return false;
            if (de.Count != deOther.Count) return false;

            for (var ceI = 0; ceI < de.Count; ceI++)
            {
                var ce = de[ceI];
                var ceOther = deOther[ceI];

                if (string.IsNullOrEmpty(ce) && string.IsNullOrEmpty(ceOther)) continue;
                if (ce.Length != ceOther.Length) return false;
                if (ce != ceOther) return false;
            }
        }

        return true;
    }

    public override string ToString()
    {
        StringBuilder output = new();

        foreach (var de in Ids)
        {
            output.Append(de is null ? "" : string.Join(":", de));
            output.Append("*");
        }

        return output.ToString().TrimEnd('*');
    }
}

================
File: EdiSource.Domain/Identifiers/IEdi.cs
================
using EdiSource.Domain.Validation.Data;

namespace EdiSource.Domain.Identifiers;

/// <summary>
///     Denotes an edi element used for patten matching.
///     It should only have three primary inheritors:<br />
///     - Segment<br />
///     - SegmentList<br />
///     - Loop<br />
///     - LoopList<br />
/// </summary>
public interface IEdi;

public interface IEdi<T> : IEdi where T : IEdi
{
    public T? Parent { get; set; }

    /// <summary>
    ///     Validations that a user can supply that will be picked up by the validator.
    ///     If add validations in a library, it is recommended to use a static
    ///     constructor to ensure they are added.
    ///     <code>
    /// static GS()
    /// {
    ///     ValidationHelper.Add&lt;GS>(x => x.GetCompositeElementOrNull(0) is null
    ///         ? [ValidationFactory.CreateCritical(x, "This makes no sense")]
    ///         : null);
    /// }
    /// </code>
    /// </summary>
    static List<IIndirectValidatable<T>> Validations { get; set; } = [];
}

================
File: EdiSource.Domain/Identifiers/IEdiId.cs
================
namespace EdiSource.Domain.Identifiers;
//
// /// <summary>
// ///     Denotes an IEdi element that has an identifier.
// ///     Used for static abstract interfaces.
// /// </summary>
// // public interface IEdiId : IEdi, IEdiId;
// public interface ISegment<TLoop>
//     : IEdi<TLoop>
//     where TLoop : ILoop
// {
//     /// <summary>
//     ///     Assigns data elements safety one segment to another.
//     ///     Useful for avoiding the issue where two segments share
//     ///     the same reference to a List.
//     ///     The parent and separators will still be shared if not specified.
//     /// </summary>
//     /// <param name="other"></param>
//     /// <param name="separators">Will use segment values if not provided</param>
//     /// <param name="parent">Will use segment values if not provided</param>
//     void Assign(Segment other, Separators? separators = null, ILoop? parent = null);
//
//     /// <summary>
//     ///     Copies data elements safety one segment to a new segment.
//     ///     Useful for avoiding the issue where two segments share
//     ///     the same reference to a List.
//     ///     The parent and separators will still be shared if not specified.
//     ///     <param name="separators">Will use segment values if not provided</param>
//     ///     <param name="parent">Will use segment values if not provided</param>
//     /// </summary>
//     /// <returns></returns>
//     Segment Copy(Separators? separators = null, ILoop? parent = null);
// }

================
File: EdiSource.Domain/Identifiers/ISegmentIdentifier.cs
================
using System.Threading.Channels;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Standard.Loops;

namespace EdiSource.Domain.Identifiers;

/// <summary>
///     Used to identify a segment
/// </summary>
public interface ISegmentIdentifier
{
    static abstract EdiId EdiId { get; }
}

/// <summary>
///     Matches segments to their identifiers
/// </summary>
/// <typeparam name="T"></typeparam>
public interface ISegmentIdentifier<T> : ISegmentIdentifier
    where T : ISegmentIdentifier<T>
{
    /// <summary>
    ///     Matches a segment using the segment identifiers
    /// </summary>
    /// <param name="segment"></param>
    /// <returns></returns>
    public static bool Matches(Segment segment)
    {
        return T.EdiId.MatchesSegment(segment);
    }

    /// <summary>
    ///     Matches the first item from a Channel using the segment identifiers
    /// </summary>
    /// <param name="segmentReader"></param>
    /// <returns></returns>
    public static async ValueTask<bool> MatchesAsync(ChannelReader<Segment> segmentReader)
    {
        await segmentReader.WaitToReadAsync();
        return segmentReader.TryPeek(out var segment) && Matches(segment);
    }
}

================
File: EdiSource.Domain/Identifiers/SegmentFactory.cs
================
using System.Threading.Channels;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;

namespace EdiSource.Domain.Identifiers;

/// <summary>
///     Used for creating segments dynamically
/// </summary>
/// <typeparam name="T"></typeparam>
/// <typeparam name="TLoop"></typeparam>
public static class SegmentLoopFactory<T, TLoop>
    where T : Segment, IEdi<TLoop>, ISegmentIdentifier<T>, new()
    where TLoop : class, ILoop
{
    /// <summary>
    ///     Creates a segment is it matches the criteria
    /// </summary>
    /// <param name="segmentReader"></param>
    /// <param name="parent"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public static async ValueTask<T> CreateAsync(ChannelReader<Segment> segmentReader, TLoop? parent = null)
    {
        await segmentReader.WaitToReadAsync();

        if (!await ISegmentIdentifier<T>.MatchesAsync(segmentReader))
            throw new ArgumentException(
                $"Expected ids of ({T.EdiId.ToString()}) but received segment: {await segmentReader.ReadAsync()}");

        var segment = await segmentReader.ReadAsync();

        var t = new T { Elements = segment.Elements, Separators = segment.Separators };
        if (t is IEdi<TLoop> e)
            e.Parent = parent;
        return t;
    }
}

================
File: EdiSource.Domain/IO/EdiReader/EdiReader.cs
================
using System.Buffers;
using System.Text;
using System.Threading.Channels;
using EdiSource.Domain.Exceptions;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Separator;
using EdiSource.Domain.Structure;

namespace EdiSource.Domain.IO.EdiReader;

public sealed class EdiReader : IEdiReader
{
    private const int BufferSize = 4096;

    public BasicEdi ReadBasicEdi(string ediString)
    {
        using var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(ediString));
        using var streamReader = new StreamReader(memoryStream);
        return ReadBasicEdi(streamReader);
    }

    public IEnumerable<Segment> ReadEdSegments(string ediString, Separators? separators = null)
    {
        using var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(ediString));
        using var streamReader = new StreamReader(memoryStream);
        return ReadEdSegments(streamReader, separators ?? Separators.DefaultSeparators);
    }

    public BasicEdi ReadBasicEdi(StreamReader streamReader)
    {
        return ReadBasicEdiAsync(streamReader).GetAwaiter().GetResult();
    }

    public IEnumerable<Segment> ReadEdSegments(StreamReader streamReader, Separators? separators = null)
    {
        return ReadEdSegmentsAsync(streamReader, separators ?? Separators.DefaultSeparators).GetAwaiter().GetResult();
    }

    public async Task<BasicEdi> ReadBasicEdiAsync(StreamReader streamReader,
        CancellationToken cancellationToken = default)
    {
        var separators = await Separators.CreateFromISA(streamReader);
        var segments = await ReadEdSegmentsAsync(streamReader, separators, cancellationToken);
        return new BasicEdi(segments.ToArray(), separators);
    }

    public async Task<List<Segment>> ReadEdSegmentsAsync(StreamReader streamReader,
        Separators? separators = null,
        CancellationToken cancellationToken = default)
    {
        var channel = Channel.CreateBounded<Segment>(1);

        List<Segment> segments = [];

        _ = Task.Run(
            async () => await ReadEdSegmentsIntoChannelAsync(streamReader, channel.Writer, separators,
                cancellationToken), cancellationToken);

        await foreach (var segment in channel.Reader.ReadAllAsync(cancellationToken)) segments.Add(segment);

        return segments;
    }

    public async Task ReadEdSegmentsIntoChannelAsync(StreamReader streamReader,
        ChannelWriter<Segment> channelWriter,
        Separators? separators = null,
        CancellationToken cancellationToken = default)
    {
        separators ??= Separators.DefaultSeparators;

        Segment segmentBuffer = new([]);

        StringBuilder stringBuffer = new();

        var buffer = ArrayPool<char>.Shared.Rent(BufferSize);

        var segmentsCreated = 0;

        try
        {
            streamReader.BaseStream.Seek(0, SeekOrigin.Begin);
            streamReader.DiscardBufferedData();

            while (streamReader.Peek() > 0)
            {
                await streamReader.ReadAsync(buffer, 0, BufferSize);

                for (var i = 0; i < BufferSize; i++)
                {
                    var c = buffer[i];
                    if (c is '\r' or '\n' or '\0') continue;

                    if (c == separators.SegmentSeparator)
                    {
                        segmentBuffer
                            .Elements
                            .Last()
                            .Add(stringBuffer.ToString());

                        stringBuffer.Clear();

                        await channelWriter.WriteAsync(segmentBuffer, cancellationToken);
                        segmentsCreated++;

                        segmentBuffer = new Segment([])
                        {
                            Separators = separators
                        };
                    }
                    else if (c == separators.DataElementSeparator)
                    {
                        segmentBuffer
                            .Elements
                            .Last()
                            .Add(stringBuffer.ToString());

                        stringBuffer.Clear();

                        segmentBuffer.Elements.Add([]);
                    }
                    else if (c == separators.CompositeElementSeparator)
                    {
                        segmentBuffer
                            .Elements
                            .Last()
                            .Add(stringBuffer.ToString());

                        stringBuffer.Clear();
                    }
                    else
                    {
                        if (segmentBuffer.Elements.Count == 0)
                            segmentBuffer.Elements.Add([]);

                        stringBuffer.Append(c);
                    }
                }
            }
        }
        finally
        {
            ArrayPool<char>.Shared.Return(buffer);
            channelWriter.Complete();
        }

        if (segmentsCreated == 0)
            throw new EdiReaderException();
    }
}

================
File: EdiSource.Domain/IO/EdiReader/IEdiReader.cs
================
using System.Threading.Channels;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Separator;
using EdiSource.Domain.Structure;

namespace EdiSource.Domain.IO.EdiReader;

public interface IEdiReader
{
    /// <summary>
    ///     Converts text to a BasicEdi format. Must be in envelope form.
    /// </summary>
    /// <param name="ediString"></param>
    /// <returns></returns>
    BasicEdi ReadBasicEdi(string ediString);

    /// <summary>
    ///     Converts a stream into BasicEdi format. Must be in envelope form.
    /// </summary>
    /// <param name="streamReader"></param>
    /// <returns></returns>
    BasicEdi ReadBasicEdi(StreamReader streamReader);

    /// <summary>
    ///     Converts a stream into BasicEdi format. Must be in envelope form.
    /// </summary>
    /// <param name="streamReader"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    Task<BasicEdi> ReadBasicEdiAsync(StreamReader streamReader, CancellationToken cancellationToken = default);

    /// <summary>
    ///     Converts text into a list of segments.
    /// </summary>
    /// <param name="ediString"></param>
    /// <param name="separators">If null, Separators.DefaultSeparators will be used</param>
    /// <returns></returns>
    IEnumerable<Segment> ReadEdSegments(string ediString, Separators? separators = null);

    /// <summary>
    ///     Converts a stream into a list of segments.
    /// </summary>
    /// <param name="streamReader"></param>
    /// <param name="separators">If null, Separators.DefaultSeparators will be used</param>
    /// <returns></returns>
    IEnumerable<Segment> ReadEdSegments(StreamReader streamReader, Separators? separators = null);

    /// <summary>
    ///     Converts a stream into a list of segments.
    /// </summary>
    /// <param name="streamReader"></param>
    /// <param name="separators">If null, Separators.DefaultSeparators will be used</param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    Task<List<Segment>> ReadEdSegmentsAsync(StreamReader streamReader, Separators? separators = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    ///     Converts contents from a stream into segments and pushes results to a channel
    /// </summary>
    /// <param name="streamReader"></param>
    /// <param name="channelWriter"></param>
    /// <param name="separators">If null, Separators.DefaultSeparators will be used</param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    Task ReadEdSegmentsIntoChannelAsync(StreamReader streamReader,
        ChannelWriter<Segment> channelWriter,
        Separators? separators = null,
        CancellationToken cancellationToken = default);
}

================
File: EdiSource.Domain/IO/Parser/EdiParser.cs
================
using System.Text;
using System.Threading.Channels;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Separator;
using EdiSource.Domain.Standard.Loops.ISA;

namespace EdiSource.Domain.IO.Parser;

public sealed class EdiParser<T> : IEdiParser<T> where T : class, ILoopInitialize<T>, new()
{
    public async Task<T> ParseEdi(StreamReader streamReader, Separators? separators = null,
        CancellationToken cancellationToken = default)
    {
        if (typeof(T) == typeof(InterchangeEnvelope))
            separators ??= await Separators.CreateFromISA(streamReader);

        var channel = Channel.CreateUnbounded<Segment>();

        var loopInitializer = T.InitializeAsync(channel.Reader, null);

        await Task.WhenAll(
            new EdiReader.EdiReader()
                .ReadEdSegmentsIntoChannelAsync(streamReader, channel.Writer, separators, cancellationToken),
            loopInitializer);

        return loopInitializer.Result;
    }

    public async Task<T> ParseEdi(FileInfo fileInfo, Separators? separators = null,
        CancellationToken cancellationToken = default)
    {
        await using var fileStream = fileInfo.OpenRead();
        using var streamReader = new StreamReader(fileStream);
        return await ParseEdi(streamReader, separators, cancellationToken);
    }

    public async Task<T> ParseEdi(string ediText, Separators? separators = null)
    {
        using var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(ediText));
        using var streamReader = new StreamReader(memoryStream);
        return await ParseEdi(streamReader, separators);
    }
}

================
File: EdiSource.Domain/IO/Parser/IEdiParser.cs
================
using EdiSource.Domain.Loop;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.IO.Parser;

public interface IEdiParser<T> where T : class, ILoopInitialize<T>, new()
{
    /// <summary>
    ///     Converts a stream to a loop.
    /// </summary>
    /// <param name="streamReader"></param>
    /// <param name="separators">
    ///     If null, Separators.DefaultSeparators will be used,
    ///     or a value will be inferred is an Interchange Envelope
    /// </param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    Task<T> ParseEdi(StreamReader streamReader, Separators? separators = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    ///     Converts a file to a loop.
    /// </summary>
    /// <param name="fileInfo"></param>
    /// <param name="separators">
    ///     If null, Separators.DefaultSeparators will be used,
    ///     or a value will be inferred is an Interchange Envelope
    /// </param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    Task<T> ParseEdi(FileInfo fileInfo, Separators? separators = null, CancellationToken cancellationToken = default);

    /// <summary>
    ///     Converts text to a loop.
    /// </summary>
    /// <param name="ediText"></param>
    /// <param name="separators">
    ///     If null, Separators.DefaultSeparators will be used,
    ///     or a value will be inferred is an Interchange Envelope
    /// </param>
    /// <returns></returns>
    Task<T> ParseEdi(string ediText, Separators? separators = null);
}

================
File: EdiSource.Domain/IO/Serializer/EdiSerializer.WriteToFile.cs
================
using EdiSource.Domain.Loop;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.IO.Serializer;

public sealed partial class EdiSerializer : IEdiSerializer
{
    public async Task WriteToFile(ILoop loop, FileInfo fileInfo, Separators? separators = null,
        bool includeNewLine = true, CancellationToken cancellationToken = default)
    {
        await using var stream = fileInfo.OpenWrite();
        await WriteToStream(loop, stream, separators, includeNewLine, cancellationToken);
    }
}

================
File: EdiSource.Domain/IO/Serializer/EdiSerializer.WriteToPrettyString.cs
================
using EdiSource.Domain.Helper.PrettyPrinting;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Loop.Extensions;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Separator;
using EdiSource.Domain.Standard.Segments;

namespace EdiSource.Domain.IO.Serializer;

public sealed partial class EdiSerializer
{
    public string WriteToPrettyString(ILoop loop, Separators? separators = null)
    {
        return PrettyPrintToStringBuilder(loop, separators: separators).ToString();

        static LoopPrinter PrettyPrintToStringBuilder(ILoop loop, LoopPrinter? loopPrinter = null,
            Separators? separators = null, bool firstIteration = true)
        {
            separators ??= Separators.DefaultSeparators;
            loopPrinter ??= new LoopPrinter();

            var loopHeader = firstIteration
                ? loopPrinter.AppendLoop(loop.GetType().Name)
                : null;

            loop.EdiAction(segment =>
                {
                    if (segment is IRefresh refresh)
                        refresh.Refresh();

                    var text = segment.WriteToStringBuilder(separators: separators).ToString();
                    loopPrinter.AppendLine(text);
                },
                segmentList =>
                {
                    foreach (var text in segmentList
                                 .Select(segment =>
                                 {
                                     if (segment is IRefresh refresh)
                                         refresh.Refresh();

                                     return segment.WriteToStringBuilder(separators: separators).ToString();
                                 }))
                        loopPrinter.AppendLine(text);
                },
                loopL =>
                {
                    if (loopL is IRefresh refresh)
                        refresh.Refresh();

                    var loopText = loopL.GetType().Name;
                    using var d = loopPrinter.AppendLoop(loopText);
                    PrettyPrintToStringBuilder(loopL, loopPrinter, separators, false);
                },
                loopList =>
                {
                    foreach (var loopL in loopList)
                    {
                        if (loopL is IRefresh refresh)
                            refresh.Refresh();

                        var loopText = loopL.GetType().Name;
                        using var d = loopPrinter.AppendLoop(loopText);
                        PrettyPrintToStringBuilder(loopL, loopPrinter, separators, false);
                    }
                });

            loopHeader?.Dispose();

            return loopPrinter;
        }
    }
}

================
File: EdiSource.Domain/IO/Serializer/EdiSerializer.WriteToStream.cs
================
using EdiSource.Domain.Loop;
using EdiSource.Domain.Loop.Extensions;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.IO.Serializer;

public sealed partial class EdiSerializer
{
    public async Task WriteToStream(ILoop loop, Stream stream, Separators? separators = null,
        bool includeNewLine = true, CancellationToken cancellationToken = default)
    {
        separators ??= Separators.DefaultSeparators;

        await using var writer = new StreamWriter(stream);

        foreach (var segment in loop.YieldChildSegments())
        {
            var text = segment.WriteToStringBuilder(separators: separators);

            if (includeNewLine)
                await writer.WriteLineAsync(text, cancellationToken);
            else
                await writer.WriteAsync(text, cancellationToken);
        }
    }
}

================
File: EdiSource.Domain/IO/Serializer/EdiSerializer.WriteToString.cs
================
using System.Text;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Loop.Extensions;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.IO.Serializer;

public sealed partial class EdiSerializer
{
    public string WriteToString(ILoop loop, Separators? separators = null,
        bool includeNewLine = true)
    {
        separators ??= Separators.DefaultSeparators;
        var stringBuilder = new StringBuilder();

        foreach (var segment in loop.YieldChildSegments())
        {
            segment.WriteToStringBuilder(stringBuilder, separators);

            if (includeNewLine)
                stringBuilder.AppendLine();
        }

        return stringBuilder.ToString();
    }
}

================
File: EdiSource.Domain/IO/Serializer/IEdiSerializer.cs
================
using EdiSource.Domain.Loop;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.IO.Serializer;

public interface IEdiSerializer
{
    /// <summary>
    ///     Writes a loop to a stream
    /// </summary>
    /// <param name="loop"></param>
    /// <param name="stream"></param>
    /// <param name="separators">If null, the separators on the segment will be used</param>
    /// <param name="includeNewLine"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    Task WriteToStream(ILoop loop, Stream stream, Separators? separators = null,
        bool includeNewLine = true, CancellationToken cancellationToken = default);


    /// <summary>
    ///     Writes a loop to a file
    /// </summary>
    /// <param name="loop"></param>
    /// <param name="fileInfo"></param>
    /// <param name="separators">If null, the separators on the segment will be used</param>
    /// <param name="includeNewLine"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    Task WriteToFile(ILoop loop, FileInfo fileInfo, Separators? separators = null,
        bool includeNewLine = true, CancellationToken cancellationToken = default);

    /// <summary>
    ///     Writes a loop to a string
    /// </summary>
    /// <param name="loop"></param>
    /// <param name="separators">If null, the separators on the segment will be used</param>
    /// <param name="includeNewLine"></param>
    /// <returns></returns>
    string WriteToString(ILoop loop, Separators? separators = null,
        bool includeNewLine = true);

    /// <summary>
    ///     Writes a loop out to a pretty string format.
    ///     Example (with '-' header instead of ' '):
    ///     <br />
    ///     <para>
    ///         TransactionSet<br />
    ///         ----ST*123<br />
    ///         ----DTP*01<br />
    ///         ----REF*02<br />
    ///         ----Loop1000<br />
    ///         --------NM1*12<br />
    ///         --------REF*3<br />
    ///     </para>
    /// </summary>
    /// <param name="loop"></param>
    /// <param name="separators">If null, the separators on the segment will be used</param>
    /// <returns></returns>
    string WriteToPrettyString(ILoop loop, Separators? separators = null);
}

================
File: EdiSource.Domain/Loop/Extensions/LoopExtensions.ActOnElementOfType.cs
================
using EdiSource.Domain.Identifiers;

namespace EdiSource.Domain.Loop.Extensions;

public static partial class LoopExtensions
{
    /// <summary>
    ///     Applies an action to matching elements of type T
    /// </summary>
    /// <param name="it"></param>
    /// <param name="action"></param>
    /// <typeparam name="T"></typeparam>
    public static void ActOnElementOfType<T>(this ILoop it, Action<T> action) where T : IEdi
    {
        var elements = it.FindEdiElement<T>();

        foreach (var element in elements) action(element);
    }
}

================
File: EdiSource.Domain/Loop/Extensions/LoopExtensions.EdiAction.cs
================
using EdiSource.Domain.Segments;

namespace EdiSource.Domain.Loop.Extensions;

public static partial class LoopExtensions
{
    /// <summary>
    ///     Executes the specified actions on different types of EDI items within the loop.
    /// </summary>
    /// <typeparam name="T">The type of the loop, which must implement <see cref="ILoop" />.</typeparam>
    /// <param name="it">The instance of the loop on which the actions are to be executed.</param>
    /// <param name="segmentAction">An action to be performed on individual segments, or null.</param>
    /// <param name="segmentListAction">An action to be performed on lists of segments, or null.</param>
    /// <param name="loopAction">An action to be performed on individual loops, or null.</param>
    /// <param name="loopListAction">An action to be performed on lists of loops, or null.</param>
    public static void EdiAction<T>(this T it,
        Action<Segment>? segmentAction = null,
        Action<SegmentList<Segment>>? segmentListAction = null,
        Action<ILoop>? loopAction = null,
        Action<LoopList<ILoop>>? loopListAction = null)
        where T : ILoop
    {
        foreach (var ediItem in it.EdiItems)
            switch (ediItem)
            {
                case null: continue;
                case Segment segment:
                    segmentAction?.Invoke(segment);
                    continue;
                case IEnumerable<Segment> segmentList:
                    segmentListAction?.Invoke([..segmentList]);
                    continue;
                case ILoop loop:
                    loopAction?.Invoke(loop);
                    continue;
                case IEnumerable<ILoop> loopList:
                    loopListAction?.Invoke([..loopList]);
                    continue;
            }
    }
}

================
File: EdiSource.Domain/Loop/Extensions/LoopExtensions.FindEdiElement.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;

namespace EdiSource.Domain.Loop.Extensions;

public static partial class LoopExtensions
{
    // /// <summary>
    // ///     Finds all EDI elements of a specified type within the given loop.
    // /// </summary>
    // /// <typeparam name="T">The type of EDI elements to find.</typeparam>
    // /// <param name="it">The loop to search within.</param>
    // /// <returns>A collection of EDI elements of the specified type.</returns>
    // public static List<T> FindEdiElement<T>(this ILoop it) where T : IEdi
    // {
    //     List<T> output = [];
    //     var type = typeof(T);
    //     var found = false;
    //
    //     EdiAction(it,
    //         x =>
    //          {
    //             if (found || x.GetType() != type) return;
    //
    //             output.Add((T)x);
    //             found = true;
    //         },
    //         segmentList =>
    //         {
    //             if (found) return;
    //
    //             foreach (var segment in segmentList)
    //             {
    //                 if (segment.GetType() != type) continue;
    //
    //                 output.Add((T)segment);
    //                 found = true;
    //             }
    //         },
    //         loop =>
    //         {
    //             if (found) return;
    //             
    //             if (loop.GetType() == type)
    //             {
    //                 output.Add((T)loop);
    //                 found = true;
    //                 return;
    //             }
    //
    //             loop.FindEdiElement<T>();
    //         },
    //         loopList =>
    //         {
    //             if (found) return;
    //
    //             foreach (var loop in loopList)
    //             {
    //                 if (loop.GetType() == type)
    //                 {
    //                     output.Add((T)loop);
    //                     found = true;
    //                 }
    //
    //                 if (found) return;
    //                 loop.FindEdiElement<T>();
    //             }
    //         });
    //
    //     return output;
    // }

    /// <summary>
    ///     Finds all EDI elements of a specified type within the given loop.
    /// </summary>
    /// <typeparam name="T">The type of EDI elements to find.</typeparam>
    /// <param name="it">The loop to search within.</param>
    /// <param name="output"></param>
    /// <returns>A collection of EDI elements of the specified type.</returns>
    public static List<T> FindEdiElement<T>(this ILoop it, List<T>? output = null) where T : IEdi
    {
        output ??= [];

        foreach (var item in it.EdiItems)
            switch (item)
            {
                case T t:
                    output.Add(t);
                    return output;
                case IEnumerable<T> ts:
                    output.AddRange(ts);
                    return output;
                case IEnumerable<Segment> segments:
                    foreach (var segment in segments)
                        if (segment is T t)
                            output.Add(t);

                    if (output.Count > 0) return output;

                    break;
                case ILoop loop:
                    loop.FindEdiElement(output);
                    if (output.Count > 0) return output;
                    break;
                case IEnumerable<ILoop> loops:
                    foreach (var loop in loops)
                        if (loop is T t)
                            output.Add(t);
                        else
                            loop.FindEdiElement(output);

                    if (output.Count > 0) return output;

                    break;
            }

        return [];
    }
}

================
File: EdiSource.Domain/Loop/Extensions/LoopExtensions.FindParent.cs
================
using EdiSource.Domain.Exceptions;
using EdiSource.Domain.Helper;

namespace EdiSource.Domain.Loop.Extensions;

public static partial class LoopExtensions
{
    /// Finds and returns the parent loop of the specified type for a given loop.
    /// <param name="loop">The loop for which the parent is to be found.</param>
    /// <param name="avoidCircularReferences">
    ///     Specifies whether to avoid circular references to prevent infinite loops.
    ///     Defaults to true.
    /// </param>
    /// <param name="maxIterations">The maximum number of iterations allowed when avoiding circular references.</param>
    /// <typeparam name="T">The type of the parent loop to be found.</typeparam>
    /// <return>The parent loop of the specified type if found; otherwise, the default value for the type.</return>
    public static T? FindParent<T>(this ILoop loop, bool avoidCircularReferences = true, int maxIterations = 1_000)
        where T : class, ILoop
    {
        if (loop is T e) return e;

        var l = loop.GetParentGeneric();

        var iterations = 0;
        while (true)
        {
            switch (l)
            {
                case null:
                    return null;
                case T value:
                    return value;
            }

            l = loop.GetParentGeneric();

            if (avoidCircularReferences && iterations++ > maxIterations)
                throw new ProbableCircularReferenceException(iterations, maxIterations);
        }
    }
}

================
File: EdiSource.Domain/Loop/Extensions/LoopExtensions.GetRoot.cs
================
using EdiSource.Domain.Exceptions;
using EdiSource.Domain.Helper;
using EdiSource.Domain.Standard.Loops.ISA;

namespace EdiSource.Domain.Loop.Extensions;

public static partial class LoopExtensions
{
    /// <summary>
    ///     Retrieves the root <see cref="ILoop" /> instance from the current loop.
    /// </summary>
    /// <param name="loop">The initial loop to start from.</param>
    /// <param name="avoidCircularReferences">
    ///     Specifies whether to avoid circular references by limiting the number of
    ///     iterations.
    /// </param>
    /// <param name="maxIterations">The maximum number of iterations allowed when avoiding circular references.</param>
    /// <returns>The root <see cref="ILoop" /> instance.</returns>
    /// <exception cref="Exception">
    ///     Thrown if the loop iteration exceeds <paramref name="maxIterations" />, indicating a
    ///     potential circular reference.
    /// </exception>
    public static InterchangeEnvelope? GetRoot(this ILoop loop, bool avoidCircularReferences = true,
        int maxIterations = 1_000)
    {
        if (loop is InterchangeEnvelope e) return e;

        var l = loop.GetParentGeneric();

        var iterations = 0;
        while (true)
        {
            switch (l)
            {
                case null:
                    return null;
                case InterchangeEnvelope envelope:
                    return envelope;
            }

            l = loop.GetParentGeneric();

            if (avoidCircularReferences && iterations++ > maxIterations)
                throw new ProbableCircularReferenceException(iterations, maxIterations);
        }
    }
}

================
File: EdiSource.Domain/Loop/Extensions/LoopExtensions.SegmentAction.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;

namespace EdiSource.Domain.Loop.Extensions;

public static partial class LoopExtensions
{
    /// <summary>
    ///     Iterates over segments in the loop and applies a given action to each segment.
    /// </summary>
    /// <typeparam name="T">The type of loop, which must implement the ILoop interface.</typeparam>
    /// <param name="it">The loop instance on which to perform the operation.</param>
    /// <param name="action">The action to apply to each segment.</param>
    /// <param name="recursive">Indicates whether to recursively apply the action to child segments. Default is true.</param>
    public static void SegmentAction<T>(this T it, Action<Segment> action, bool recursive = true)
        where T : ILoop
    {
        EdiAction(it,
            action,
            segmentList =>
            {
                foreach (var segment in segmentList) action(segment);
            },
            loop =>
            {
                if (!recursive) return;
                foreach (var childSegment in loop.YieldChildSegments()) action(childSegment);
            },
            loopList =>
            {
                if (!recursive) return;
                foreach (var childSegment in loopList.SelectMany(x => x.YieldChildSegments())) action(childSegment);
            });
    }

    public static IEnumerable<Segment> YieldSegments(this IEdi it)
    {
        switch (it)
        {
            case Segment segment:
                yield return segment;
                break;
            case IEnumerable<Segment> segments:
                foreach (var segment in segments)
                {
                    yield return segment;
                }

                break;
            case ILoop loop:
                foreach (var segment in loop.YieldChildSegments())
                {
                    yield return segment;
                }

                break;
            case IEnumerable<ILoop> loopList:
                foreach (var loop in loopList)
                {
                    foreach (var segment in loop.YieldChildSegments())
                    {
                        yield return segment;
                    }
                }

                break;
        }
    }

    public static int CountSegments(this IEdi it)
    {
        var output = 0;

        switch (it)
        {
            case Segment:
                output++;
                break;
            case IEnumerable<Segment> segments:
                output += segments.Count();

                break;
            case ILoop loop:
                output += loop.YieldChildSegments().Count();

                break;
            case IEnumerable<ILoop> loopList:
                output += loopList.Sum(loop => loop.YieldChildSegments().Count());

                break;
        }

        return output;
    }
}

================
File: EdiSource.Domain/Loop/Extensions/LoopExtensions.YieldChildLoops.cs
================
namespace EdiSource.Domain.Loop.Extensions;

public static partial class LoopExtensions
{
    /// <summary>
    ///     Yields the child loops of the specified loop, optionally in a recursive manner.
    /// </summary>
    /// <typeparam name="T">The type of the loop, which must implement <see cref="ILoop" />.</typeparam>
    /// <param name="it">The instance of the loop from which to yield child loops.</param>
    /// <param name="recursive">A flag indicating whether to yield child loops recursively.</param>
    /// <returns>An enumerable collection of child loops.</returns>
    public static List<ILoop> YieldChildLoops<T>(this T it, bool recursive = true)
        where T : ILoop
    {
        List<ILoop> items = [];

        EdiAction(it,
            loopAction: loop =>
            {
                items.Add(loop);

                if (recursive)
                    items.AddRange(loop.YieldChildLoops());
            },
            loopListAction: loopList =>
            {
                items.AddRange(loopList);

                if (recursive)
                    items.AddRange(loopList.SelectMany(x => x.YieldChildLoops()));
            });

        return items;
    }
}

================
File: EdiSource.Domain/Loop/Extensions/LoopExtensions.YieldChildSegments.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;

namespace EdiSource.Domain.Loop.Extensions;

public static partial class LoopExtensions
{
    /// <summary>
    ///     Yields all child segments of the given loop.
    ///     Optionally performs this action recursively on nested loops.
    /// </summary>
    /// <typeparam name="T">Type of the loop, which must implement ILoop.</typeparam>
    /// <param name="it">The loop instance from which child segments are to be retrieved.</param>
    /// <param name="recursive">If true, the function will include child segments from nested loops recursively.</param>
    /// <returns>An IEnumerable of Segment representing the child segments of the loop.</returns>
    public static IEnumerable<Segment> YieldChildSegments<T>(this T it, bool recursive = true)
        where T : ILoop
    {
        List<Segment> items = [];
        SegmentAction(it, x => items.Add(x), recursive);
        return items;
    }
}

================
File: EdiSource.Domain/Loop/ILoop.cs
================
using EdiSource.Domain.Identifiers;

namespace EdiSource.Domain.Loop;

/// <summary>
///     Denotes a loop
/// </summary>
public interface ILoop : IEdi
{
    /// <summary>
    ///     The items of the loop including:<br />
    ///     - Segment<br />
    ///     - Segment lists<br />
    ///     - Loops<br />
    ///     - Loop lists<br />
    ///     <br />
    ///     Used for dynamic recursive calls.
    /// </summary>
    List<IEdi?> EdiItems { get; }
}

================
File: EdiSource.Domain/Loop/ILoopInitialize.cs
================
using System.Threading.Channels;
using EdiSource.Domain.Segments;

namespace EdiSource.Domain.Loop;

/// <summary>
///     The loop initializing for reading from a channel asynchronously.
///     Used for certain methods that deal with a generic ILoop.
/// </summary>
/// <typeparam name="TSelf"></typeparam>
public interface ILoopInitialize<TSelf> : ILoop where TSelf : ILoop
{
    static abstract Task<TSelf> InitializeAsync(ChannelReader<Segment> segmentReader, ILoop? parent);
}

/// <summary>
///     The loop initializing for reading from a channel asynchronously.
/// </summary>
/// <typeparam name="TParent"></typeparam>
/// <typeparam name="TSelf"></typeparam>
public interface ILoopInitialize<in TParent, TSelf>
    : ILoopInitialize<TSelf>
    where TParent : ILoop
    where TSelf : ILoop
{
    static abstract Task<TSelf> InitializeAsync(ChannelReader<Segment> segmentReader, TParent? parent);
}

================
File: EdiSource.Domain/Loop/LoopList.cs
================
using EdiSource.Domain.Identifiers;

namespace EdiSource.Domain.Loop;

/// <summary>
///     Notes a list of loops.
///     In practice, it is a List of ILoop with an IEdi interface for pattern matching purposes.
/// </summary>
/// <typeparam name="T"></typeparam>
public sealed class LoopList<T> : List<T>, IEdi
    where T : ILoop;

================
File: EdiSource.Domain/Segments/Extensions/SegmentExtensions.Bool.cs
================
using EdiSource.Domain.Exceptions;

namespace EdiSource.Domain.Segments.Extensions;

public static partial class SegmentExtensions
{
    /// <summary>
    ///     Attempts to parse a bool from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="trueValue">The value that is expected when true</param>
    /// <param name="compositeElement"></param>
    /// <param name="implicitFalse">
    ///     When true, if element is not trueValue then false.
    ///     When false, if element is not trueValue or falseValue then null
    /// </param>
    /// <param name="falseValue">The value expected when false</param>
    /// <returns></returns>
    public static bool? GetBool(this Segment it, int dataElement, string trueValue, int compositeElement = 0,
        bool implicitFalse = true,
        string falseValue = "N")
    {
        if (it.GetCompositeElementOrNull(dataElement, compositeElement) is not { } element) return null;

        return element == trueValue
            ? true
            : element == falseValue
                ? false
                : implicitFalse
                    ? false
                    : null;
    }

    /// <summary>
    ///     Attempts to parse a bool from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="trueValue">The value that is expected when true</param>
    /// <param name="compositeElement"></param>
    /// <param name="implicitFalse">
    ///     When true, if element is not trueValue then false.
    ///     When false, if element is not trueValue or falseValue then null
    /// </param>
    /// <param name="falseValue">The value expected when false</param>
    /// <returns></returns>
    public static bool GetBoolRequired(this Segment it, int dataElement, string trueValue, int compositeElement = 0,
        bool implicitFalse = true,
        string falseValue = "N")
    {
        return GetBool(it, dataElement, trueValue, compositeElement, implicitFalse, falseValue) ??
               throw new DataElementParsingError(dataElement, compositeElement, typeof(bool));
    }

    /// <summary>
    ///     Attempts to set a bool from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="trueValue"></param>
    /// <param name="falseValue"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetBool(this Segment it, bool value, string trueValue, string falseValue, int dataElement,
        int compositeElement = 0, bool create = true)
    {
        var text = value ? trueValue : falseValue;
        return it.SetCompositeElement(text, dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set a bool from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="trueValue"></param>
    /// <param name="falseValue"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetBool(this Segment it, bool? value, string trueValue, string falseValue, int dataElement,
        int compositeElement = 0, bool create = true)
    {
        if (value is null) return false;

        var text = value.Value ? trueValue : falseValue;
        return it.SetCompositeElement(text, dataElement, compositeElement, create);
    }
}

================
File: EdiSource.Domain/Segments/Extensions/SegmentExtensions.DateOnly.cs
================
using System.Globalization;
using EdiSource.Domain.Exceptions;

namespace EdiSource.Domain.Segments.Extensions;

public static partial class SegmentExtensions
{
    /// <summary>
    ///     Attempts to parse a DateOnly from element.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static DateOnly? GetDateOnly(this Segment it, int dataElement, int compositeElement = 0,
        string format = "yyyyMMdd")
    {
        if (it.GetCompositeElementOrNull(dataElement, compositeElement) is not { } element) return null;

        return DateOnly.TryParseExact(element, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out var date)
            ? date
            : null;
    }

    /// <summary>
    ///     Attempts to parse a DateOnly from element.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static DateOnly GetDateOnlyRequired(this Segment it, int dataElement, int compositeElement = 0,
        string format = "yyyyMMdd")
    {
        return GetDateOnly(it, dataElement, compositeElement, format) ??
               throw new DataElementParsingError(dataElement, compositeElement, typeof(DateOnly));
    }

    /// <summary>
    ///     Attempts to set a DateOnly from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetDateOnly(this Segment it, DateOnly value, int dataElement,
        int compositeElement = 0, string format = "yyyyMMdd", bool create = true)
    {
        return it.SetCompositeElement(value.ToString(format), dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set a DateOnly from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetDateOnly(this Segment it, DateOnly? value, int dataElement,
        int compositeElement = 0, string format = "yyyyMMdd", bool create = true)
    {
        return value is not null
               && it.SetCompositeElement(value.Value.ToString(format), dataElement, compositeElement, create);
    }
}

================
File: EdiSource.Domain/Segments/Extensions/SegmentExtensions.DateTime.cs
================
using System.Globalization;
using EdiSource.Domain.Exceptions;

namespace EdiSource.Domain.Segments.Extensions;

public static partial class SegmentExtensions
{
    /// <summary>
    ///     Attempts to parse a date from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static DateTime? GetDate(this Segment it, int dataElement, int compositeElement = 0,
        string format = "yyyyMMdd")
    {
        if (it.GetCompositeElementOrNull(dataElement, compositeElement) is not { } element) return null;

        return DateTime.TryParseExact(element, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out var date)
            ? date
            : null;
    }

    /// <summary>
    ///     Attempts to parse a date from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static DateTime GetDateRequired(this Segment it, int dataElement, int compositeElement = 0,
        string format = "yyyyMMdd")
    {
        return GetDate(it, dataElement, compositeElement, format) ??
               throw new DataElementParsingError(dataElement, compositeElement, typeof(DateTime));
    }

    /// <summary>
    ///     Attempts to set a date from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetDate(this Segment it, DateTime value, int dataElement, int compositeElement = 0,
        string format = "yyyyMMdd", bool create = true)
    {
        return it.SetCompositeElement(value.ToString(format), dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set a date from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetDate(this Segment it, DateTime? value, int dataElement, int compositeElement = 0,
        string format = "yyyyMMdd", bool create = true)
    {
        return value is not null
               && it.SetCompositeElement(value.Value.ToString(format), dataElement, compositeElement, create);
    }
}

================
File: EdiSource.Domain/Segments/Extensions/SegmentExtensions.Decimal.cs
================
using System.Globalization;
using EdiSource.Domain.Exceptions;

namespace EdiSource.Domain.Segments.Extensions;

public static partial class SegmentExtensions
{
    /// <summary>
    ///     Attempts to parse a decimal from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <returns></returns>
    public static decimal? GetDecimal(this Segment it, int dataElement, int compositeElement = 0)
    {
        if (it.GetCompositeElementOrNull(dataElement, compositeElement) is not { } element) return null;

        return decimal.TryParse(element, out var value)
            ? value
            : null;
    }

    /// <summary>
    ///     Attempts to parse a decimal from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <returns></returns>
    public static decimal GetDecimalRequired(this Segment it, int dataElement, int compositeElement = 0)
    {
        return GetDecimal(it, dataElement, compositeElement) ??
               throw new DataElementParsingError(dataElement, compositeElement, typeof(decimal));
    }

    /// <summary>
    ///     Attempts to set a decimal from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetDecimal(this Segment it, decimal value, int dataElement, int compositeElement = 0,
        string? format = null, bool create = true)
    {
        var text = format is null ? value.ToString(CultureInfo.InvariantCulture) : value.ToString(format);
        return it.SetCompositeElement(text, dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set a decimal from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetDecimal(this Segment it, decimal? value, int dataElement, int compositeElement = 0,
        string? format = null, bool create = true)
    {
        if (value is null) return false;
        var text = format is null ? value.Value.ToString(CultureInfo.InvariantCulture) : value.Value.ToString(format);
        return it.SetCompositeElement(text, dataElement, compositeElement, create);
    }
}

================
File: EdiSource.Domain/Segments/Extensions/SegmentExtensions.Enum.cs
================
using EdiSource.Domain.Exceptions;

namespace EdiSource.Domain.Segments.Extensions;

public static partial class SegmentExtensions
{
    /// <summary>
    ///     Attempts to parse an enum from an element via enum name.
    ///     If tryAddUnderscore is true, it will also try an enum name with
    ///     an '_' prefix to enable enums that start with not allowed characters.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="tryAddUnderscore"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static TEnum? GetEnum<TEnum>(this Segment it, int dataElement, int compositeElement = 0,
        bool tryAddUnderscore = true)
        where TEnum : struct, Enum
    {
        if (it.GetCompositeElementOrNull(dataElement, compositeElement) is not { } element) return null;

        return Enum.TryParse<TEnum>(element, out var value)
            ? value
            : tryAddUnderscore
                ? Enum.TryParse($"_{element}", out value)
                    ? value
                    : null
                : null;
    }

    /// <summary>
    ///     Attempts to parse an enum from an element via a mapping function.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="fun"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static TEnum? GetEnum<TEnum>(this Segment it, Func<string, TEnum> fun, int dataElement,
        int compositeElement = 0)
        where TEnum : struct, Enum
    {
        if (it.GetCompositeElementOrNull(dataElement, compositeElement) is not { } element) return null;

        return fun(element);
    }

    /// <summary>
    ///     Attempts to parse an enum from an element via a mapping function.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="fun"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static TEnum GetEnumRequired<TEnum>(this Segment it, Func<string, TEnum> fun, int dataElement,
        int compositeElement = 0)
        where TEnum : struct, Enum
    {
        return GetEnum(it, fun, dataElement, compositeElement) ??
               throw new DataElementParsingError(dataElement, compositeElement, typeof(TEnum));
    }


    /// <summary>
    ///     Attempts to parse an enum from an element via enum name.
    ///     If tryAddUnderscore is true, it will also try an enum name with
    ///     an '_' prefix to enable enums that start with not allowed characters.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="tryAddUnderscore"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static TEnum GetEnumRequired<TEnum>(this Segment it, int dataElement, int compositeElement = 0,
        bool tryAddUnderscore = true)
        where TEnum : struct, Enum
    {
        return GetEnum<TEnum>(it, dataElement, compositeElement, tryAddUnderscore) ??
               throw new DataElementParsingError(dataElement, compositeElement, typeof(TEnum));
    }

    /// <summary>
    ///     Attempts to set an enum using a basic to string conversion.
    ///     If tryRemoveUnderscore is true, it will remove the '_' from the enum name
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="create"></param>
    /// <param name="tryRemoveUnderscore"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static bool SetEnum<TEnum>(this Segment it, TEnum value, int dataElement, int compositeElement = 0,
        bool create = true, bool tryRemoveUnderscore = true)
        where TEnum : struct, Enum
    {
        var text = value.ToString().AsSpan();
        if (tryRemoveUnderscore && text[0] != '_') text = text[1..];

        return it.SetCompositeElement(text.ToString(), dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set an enum using a basic to string conversion.
    ///     If tryRemoveUnderscore is true, it will remove the '_' from the enum name
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="create"></param>
    /// <param name="tryRemoveUnderscore"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static bool SetEnum<TEnum>(this Segment it, TEnum? value, int dataElement, int compositeElement = 0,
        bool create = true, bool tryRemoveUnderscore = true)
        where TEnum : struct, Enum
    {
        if (value is null) return false;

        var text = value.ToString().AsSpan();
        if (tryRemoveUnderscore && text[0] != '_') text = text[1..];

        return it.SetCompositeElement(text.ToString(), dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set an enum using a mapping function.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="fun">The mapping function</param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="create"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static bool SetEnum<TEnum>(this Segment it, TEnum value, Func<TEnum, string> fun, int dataElement,
        int compositeElement = 0,
        bool create = true)
        where TEnum : struct, Enum
    {
        return it.SetCompositeElement(fun(value), dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set an enum using a mapping function.
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="fun">The mapping function</param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="create"></param>
    /// <typeparam name="TEnum"></typeparam>
    /// <returns></returns>
    public static bool SetEnum<TEnum>(this Segment it, TEnum? value, Func<TEnum, string> fun, int dataElement,
        int compositeElement = 0,
        bool create = true)
        where TEnum : struct, Enum
    {
        return value is not null
               && it.SetCompositeElement(fun(value.Value), dataElement, compositeElement, create);
    }
}

================
File: EdiSource.Domain/Segments/Extensions/SegmentExtensions.Int.cs
================
using EdiSource.Domain.Exceptions;

namespace EdiSource.Domain.Segments.Extensions;

public static partial class SegmentExtensions
{
    /// <summary>
    ///     Attempts to parse an int from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <returns></returns>
    public static int? GetInt(this Segment it, int dataElement, int compositeElement = 0)
    {
        if (it.GetCompositeElementOrNull(dataElement, compositeElement) is not { } element) return null;

        return int.TryParse(element, out var value)
            ? value
            : null;
    }

    /// <summary>
    ///     Attempts to parse an int from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <returns></returns>
    public static int GetIntRequired(this Segment it, int dataElement, int compositeElement = 0)
    {
        return GetInt(it, dataElement, compositeElement) ??
               throw new DataElementParsingError(dataElement, compositeElement, typeof(int));
    }

    /// <summary>
    ///     Attempts to set an int from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetInt(this Segment it, int value, int dataElement, int compositeElement = 0,
        string? format = null, bool create = true)
    {
        var text = format is null ? value.ToString() : value.ToString(format);
        return it.SetCompositeElement(text, dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set an int from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetInt(this Segment it, int? value, int dataElement, int compositeElement = 0,
        string? format = null, bool create = true)
    {
        if (value is null) return false;

        var text = format is null ? value.Value.ToString() : value.Value.ToString(format);
        return it.SetCompositeElement(text, dataElement, compositeElement, create);
    }
}

================
File: EdiSource.Domain/Segments/Extensions/SegmentExtensions.TimeOnly.cs
================
using System.Globalization;
using EdiSource.Domain.Exceptions;

namespace EdiSource.Domain.Segments.Extensions;

public static partial class SegmentExtensions
{
    /// <summary>
    ///     Attempts to parse a TimeOnly from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static TimeOnly? GetTimeOnly(this Segment it, int dataElement, int compositeElement = 0,
        string format = "HHmm")
    {
        if (it.GetCompositeElementOrNull(dataElement, compositeElement) is not { } element) return null;

        return TimeOnly.TryParseExact(element, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out var time)
            ? time
            : null;
    }

    /// <summary>
    ///     Attempts to parse a TimeOnly from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <returns></returns>
    public static TimeOnly GetTimeOnlyRequired(this Segment it, int dataElement, int compositeElement = 0,
        string format = "HHmm")
    {
        return GetTimeOnly(it, dataElement, compositeElement, format) ??
               throw new DataElementParsingError(dataElement, compositeElement, typeof(TimeOnly));
    }

    /// <summary>
    ///     Attempts to set a TimeOnly from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetTimeOnly(this Segment it, TimeOnly value, int dataElement,
        int compositeElement = 0, string format = "HHmm", bool create = true)
    {
        return it.SetCompositeElement(value.ToString(format), dataElement, compositeElement, create);
    }

    /// <summary>
    ///     Attempts to set a TimeOnly from an element
    /// </summary>
    /// <param name="it"></param>
    /// <param name="value"></param>
    /// <param name="dataElement"></param>
    /// <param name="compositeElement"></param>
    /// <param name="format"></param>
    /// <param name="create">Will create the preceding composite data elements and composite elements if needed</param>
    /// <returns></returns>
    public static bool SetTimeOnly(this Segment it, TimeOnly? value, int dataElement,
        int compositeElement = 0, string format = "HHmm", bool create = true)
    {
        return value is not null &&
               it.SetCompositeElement(value.Value.ToString(format), dataElement, compositeElement, create);
    }
}

================
File: EdiSource.Domain/Segments/Extensions/SegmentExtensions.WriteToStringBuilder.cs
================
using System.Text;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.Segments.Extensions;

public static partial class SegmentExtensions
{
    public static StringBuilder WriteToStringBuilder<T>(this T segment, StringBuilder? stringBuilder = null,
        Separators? separators = default)
        where T : Segment
    {
        stringBuilder ??= new StringBuilder();
        separators ??= Separators.DefaultSeparators;

        if (segment.Elements.Count == 0)
            return stringBuilder;

        foreach (var element in segment.Elements.SkipLast(1))
        {
            stringBuilder.AppendJoin(separators.CompositeElementSeparator, (string[])element);
            stringBuilder.Append(separators.DataElementSeparator);
        }

        stringBuilder.AppendJoin(separators.CompositeElementSeparator, (string[])segment.Elements.Last());
        stringBuilder.Append(separators.SegmentSeparator);

        return stringBuilder;
    }
}

================
File: EdiSource.Domain/Segments/Segment.cs
================
using EdiSource.Domain.Elements;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.Segments;

/// <summary>
///     A basic implementation of Segment
/// </summary>
public partial class Segment
{
    private Separators? _separators;

    public Segment(Segment segment, ILoop? parent = null)
    {
        Elements = segment.Elements;
        Separators = segment.Separators;
    }

    public Segment(IEnumerable<Element>? elements = null, Separators? separators = default, ILoop? parent = null)
    {
        Elements = elements?.ToList() ?? [];
        Separators = separators ?? Separators.DefaultSeparators;
    }

    public Segment(string segmentText, Separators? separators = null, ILoop? parent = null)
    {
        Elements = ReadElements(segmentText, separators).ToList();
        Separators = separators ?? Separators.DefaultSeparators;
    }

    public string this[int index]
    {
        get => this[index, 0];
        set => this[index, 0] = value;
    }

    public string this[int dataElement, int compositeElement]
    {
        get => GetCompositeElement(dataElement, compositeElement);
        set => SetCompositeElement(value, dataElement, compositeElement);
    }

    public IList<Element> Elements { get; set; }

    public Separators Separators
    {
        get => _separators ?? Separators.DefaultSeparators;
        set => _separators = value;
    }

    public Element GetElement(int elementIndex)
    {
        return Elements[elementIndex];
    }

    public Element? GetElementOrNull(int elementIndex)
    {
        return ElementExists(elementIndex)
            ? GetElement(elementIndex)
            : null;
    }

    public string GetCompositeElement(int dataElementIndex, int compositeElementIndex = 0)
    {
        return Elements[dataElementIndex][compositeElementIndex];
    }

    public string? GetCompositeElementOrNull(int dataElementIndex, int compositeElementIndex = 0)
    {
        return CompositeElementExists(dataElementIndex, compositeElementIndex)
            ? GetCompositeElement(dataElementIndex, compositeElementIndex)
            : null;
    }

    public bool SetDataElement(int elementIndex, bool create = true, params string[] values)
    {
        if (create && !ElementExists(elementIndex))
            while (elementIndex >= Elements.Count)
                Elements.Add([]);
        else if (!ElementExists(elementIndex)) return false;

        var element = GetElement(elementIndex);

        element.Clear();

        foreach (var value in values)
            element.Add(value);

        return true;
    }

    public bool SetCompositeElement(string value, int dataElementIndex, int compositeElementIndex = 0,
        bool create = true)
    {
        if (create && !CompositeElementExists(dataElementIndex, compositeElementIndex))
            while (dataElementIndex >= Elements.Count)
                if (dataElementIndex == Elements.Count - 1)
                    for (var i = 0; i < compositeElementIndex; i++)
                        Elements[dataElementIndex].Add(string.Empty);
                else
                    Elements.Add([string.Empty]);
        else if (!CompositeElementExists(dataElementIndex, compositeElementIndex)) return false;

        Elements[dataElementIndex][compositeElementIndex] = value;
        return true;
    }

    public bool ElementExists(int elementIndex)
    {
        return Elements.InsideBounds(elementIndex);
    }

    public bool CompositeElementExists(int dataElementIndex, int compositeElementIndex = 0)
    {
        return Elements.InsideBounds(dataElementIndex)
               && Elements[dataElementIndex].InsideBounds(compositeElementIndex);
    }

    public bool CompositeElementNotNullOrEmpty(int dataElementIndex, int compositeElementIndex = 0)
    {
        return Elements.InsideBounds(dataElementIndex)
               && Elements[dataElementIndex].InsideBounds(compositeElementIndex)
               && Elements[dataElementIndex][compositeElementIndex].Length > 0;
    }

    public static IEnumerable<Segment> ReadMultipleSegment(string segmentText, Separators? separators = null)
    {
        separators ??= Separators.DefaultSeparators;

        return segmentText
            .Trim()
            .Split(separators.SegmentSeparator)
            .Select(x => new Segment(ReadElements(x, separators), separators));
    }

    public static IEnumerable<Element> ReadElements(string segmentText, Separators? separators = null)
    {
        separators ??= Separators.DefaultSeparators;

        return segmentText
            .Trim()
            .Trim(separators.SegmentSeparator)
            .Split(separators.DataElementSeparator)
            .Select(x => x.Split(separators.CompositeElementSeparator))
            .Select(x => new Element(x));
    }

    public override string ToString()
    {
        return this.WriteToStringBuilder(separators: Separators).ToString();
    }

    public string ToString(Separators separators)
    {
        return this.WriteToStringBuilder(separators: separators).ToString();
    }

    public void Assign(Segment other, Separators? separators = null, ILoop? parent = null)
    {
        Elements = other.Elements.Select(e => new Element(e)).ToList();

        if (separators is not null)
            Separators = separators;
    }

    public Segment Copy(Separators? separators = null, ILoop? parent = null)
    {
        var elements = Elements.Select(e => new Element(e)).ToList();
        return new Segment(elements, separators ?? Separators);
    }
}

================
File: EdiSource.Domain/Segments/Segment.Equality.cs
================
namespace EdiSource.Domain.Segments;

public partial class Segment
{
    public override bool Equals(object? obj)
    {
        if (obj is not Segment segment) return false;
        return Equals(segment);
    }

    public bool Equals(Segment other)
    {
        if (other.Elements.Count != Elements.Count) return false;

        foreach (var (e, x) in other.Elements.Zip(Elements, (s, s1) => (s, s1)))
            if (!e.Equals(x))
                return false;

        return true;
    }

    public static bool operator ==(Segment left, Segment right)
    {
        return Equals(left, right);
    }

    public static bool operator !=(Segment element1, Segment element2)
    {
        return !(element1 == element2);
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(this);
    }
}

================
File: EdiSource.Domain/Segments/SegmentList.cs
================
using EdiSource.Domain.Identifiers;

namespace EdiSource.Domain.Segments;

/// <summary>
///     Notes a list of segments.
///     In practice, it is a List of Segment with an IEdi interface for pattern matching purposes.
/// </summary>
/// <typeparam name="T"></typeparam>
public sealed class SegmentList<T> : List<T>, IEdi
    where T : Segment;

================
File: EdiSource.Domain/Separator/Separators.CreateISA.cs
================
namespace EdiSource.Domain.Separator;

public partial class Separators
{
    /// <summary>
    ///     Parses out the segments from an ISA stream
    /// </summary>
    /// <param name="streamReader"></param>
    /// <returns></returns>
    public static Task<Separators> CreateFromISA(StreamReader streamReader)
    {
        streamReader.BaseStream.Position = 3;
        var dataElementSeparator = (char)streamReader.Peek();
        streamReader.DiscardBufferedData();

        streamReader.BaseStream.Position = 104;
        var compositeElementSeparator = (char)streamReader.Peek();
        streamReader.DiscardBufferedData();

        streamReader.BaseStream.Position = 105;
        var segmentSeparator = (char)streamReader.Peek();
        streamReader.DiscardBufferedData();

        streamReader.BaseStream.Position = 0;

        return Task.FromResult(new Separators(segmentSeparator, dataElementSeparator, compositeElementSeparator));
    }

    /// <summary>
    ///     Parses out the segment values from an ISA text span
    /// </summary>
    /// <param name="ediText"></param>
    /// <returns></returns>
    public static Separators CreateFromISA(ReadOnlySpan<char> ediText)
    {
        return new Separators(ediText[3], ediText[104], ediText[105]);
    }
}

================
File: EdiSource.Domain/Separator/Separators.cs
================
namespace EdiSource.Domain.Separator;

/// <summary>
///     The <c>Separators</c> class represents the characters used to delimit different parts of an EDI message.
/// </summary>
public sealed partial class Separators
{
    /// <summary>
    ///     A static instance of <see cref="Separators" /> initialized with default EDI separators.
    ///     The <see cref="SegmentSeparator" /> is '~', the <see cref="DataElementSeparator" /> is '*',
    ///     and the <see cref="CompositeElementSeparator" /> is ':'.
    ///     <br /><br />
    ///     These values can be changed during application start if other defaults are wanted.
    /// </summary>
    public static readonly Separators DefaultSeparators = new('~', '*', ':');

    /// This class provides properties to store segment, data element, and composite element separators.
    /// Additionally, it includes methods to create instances of the Separators class using the ISA segment of an EDI document.
    public Separators(char segmentSeparator, char dataElementSeparator, char compositeElementSeparator)
    {
        SegmentSeparator = segmentSeparator;
        DataElementSeparator = dataElementSeparator;
        CompositeElementSeparator = compositeElementSeparator;
    }

    public Separators()
    {
    }

    /// <summary>
    ///     Gets or sets the character used to separate segments in an EDI message.
    /// </summary>
    /// <value>
    ///     The character used to separate segments from other segments. Default value is '~'.
    /// </value>
    public char SegmentSeparator { get; set; } = '~';

    /// <summary>
    ///     Gets or sets the character used to separate individual data elements within a segment.
    /// </summary>
    /// <value>
    ///     The character used to separate data elements within a segment element. Default value is '*'.
    /// </value>
    public char DataElementSeparator { get; set; } = '*';

    /// <summary>
    ///     Gets or sets the character used to separate composite elements within a data element.
    /// </summary>
    /// <value>
    ///     The character used to separate composite elements within a data element. Default value is ':'.
    /// </value>
    public char CompositeElementSeparator { get; set; } = ':';
}

================
File: EdiSource.Domain/Standard/Date/DateFormats.cs
================
namespace EdiSource.Domain.Standard.Date;

public static class DateFormats
{
    public static readonly HashSet<string> StandardFormats =
    [
        "yy", "MMMYYYY", "yyyyMM", "yyyy'Q'q", "yyyy", "yyMMdd", "yyyyMMdd",
        "dd", "MMddyyyy", "yyyyMMddHHmm", "yyyyMMddHHmmss", "yDDD",
        "yyMMMdd", "MMyyyy", "MMdd", "MM", "HHmm", "DDD", "HHmmss",
        "ddMMyyHHmm", "MMddyy", "yyDDD", "", "yyyyMMM", "MMM"
    ];
}

================
File: EdiSource.Domain/Standard/Loops/ISA/CommunicationIdType.cs
================
namespace EdiSource.Domain.Standard.Loops.ISA;

public enum CommunicationIdType
{
    NoAuthorizationInfo = 00,
    UCSCommunicationsId = 01,
    EDXCommunicationsId = 02,
    AdditionalDataIdentification = 03,
    RailCommunicationsId = 04,
    DoDCommunicationId = 05,
    USFederalGovtCommunicationId = 06,
    TruckCommunicationsId = 07,
    OceanCommunicationsId = 08
}

================
File: EdiSource.Domain/Standard/Loops/ISA/CommunicationIdTypeExtensions.cs
================
namespace EdiSource.Domain.Standard.Loops.ISA;

public static class CommunicationIdTypeExtensions
{
    public static string? EnumToString(this CommunicationIdType value)
    {
        return value switch
        {
            CommunicationIdType.NoAuthorizationInfo => "00",
            CommunicationIdType.UCSCommunicationsId => "01",
            CommunicationIdType.EDXCommunicationsId => "02",
            CommunicationIdType.AdditionalDataIdentification => "03",
            CommunicationIdType.RailCommunicationsId => "04",
            CommunicationIdType.DoDCommunicationId => "05",
            CommunicationIdType.USFederalGovtCommunicationId => "06",
            CommunicationIdType.TruckCommunicationsId => "07",
            CommunicationIdType.OceanCommunicationsId => "08",
            _ => null
        };
    }

    public static CommunicationIdType? StringToEnum(this string? value)
    {
        return value switch
        {
            "00" => CommunicationIdType.NoAuthorizationInfo,
            "01" => CommunicationIdType.UCSCommunicationsId,
            "02" => CommunicationIdType.EDXCommunicationsId,
            "03" => CommunicationIdType.AdditionalDataIdentification,
            "04" => CommunicationIdType.RailCommunicationsId,
            "05" => CommunicationIdType.DoDCommunicationId,
            "06" => CommunicationIdType.USFederalGovtCommunicationId,
            "07" => CommunicationIdType.TruckCommunicationsId,
            "08" => CommunicationIdType.OceanCommunicationsId,
            _ => null
        };
    }
}

================
File: EdiSource.Domain/Standard/Loops/ISA/IdentificationCode.cs
================
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.SourceGeneration;

namespace EdiSource.Domain.Standard.Loops.ISA;

public enum IdentificationCode
{
    Duns = 01,
    SCAC = 02,
    FMC = 03,
    IATA = 04,
    GLN = 07,
    UCCEDICommID = 08,
    X121 = 09,
    DoDActivityAddressCode = 10,
    DEA = 11,
    Phone = 12,
    UCSCode = 13,
    DunsPlusSuffix = 14,
    PetroleumAccountantsSocietyOfCanadaCode = 15,
    DunsNumberWith4CharSuffix = 16,
    ABARoutingNumber = 17,
    AARStandardDistributionCode = 18,
    EDICACommIDNumber = 19,
    HealthIndustryNumber = 20,
    IPEDS = 21,
    FICE = 22,
    NCESCommonCoreNumber = 23,
    CollegeBoardATPCode = 24,
    ACTCode = 25,
    StatisticsCanadaPostsecondaryList = 26,
    CMSCarrierIdentificationNumber = 27,
    CMSFiscalIntermediaryIdentificationNumber = 28,
    CMSMedicareProviderSupplierNumber = 29,
    USFederalTaxIdentificationNumber = 30,
    IAIABCJurisdictionIdentificationNumberPlus4 = 31,
    USFEIN = 32,
    NAICCompanyCode = 33,
    MedicaidProviderSupplierNumber = 34,
    StatisticsCanadaCollegeStudentInfoSystemCode = 35,
    StatisticsCanadaUniversityStudentInfoSystemCode = 36,
    SocietyOfPropertyInfoCompilersAndAnalysts = 37,
    CollegeBoardACTSecondaryInstitutionCode = 38,
    AMECOPCommunicationID = 39,
    NRMAAssigned = 40,
    SAFERUserIdentificationNumber = 41,
    StandardAddressNumber = 42,
    MutuallyDefined = 43
}

public static class IdentificationCodeExtensions
{
    public static string? EnumToString(this IdentificationCode value)
    {
        return value switch
        {
            IdentificationCode.Duns => "01",
            IdentificationCode.SCAC => "02",
            IdentificationCode.FMC => "03",
            IdentificationCode.IATA => "04",
            IdentificationCode.GLN => "07",
            IdentificationCode.UCCEDICommID => "08",
            IdentificationCode.X121 => "09",
            IdentificationCode.DoDActivityAddressCode => "10",
            IdentificationCode.DEA => "11",
            IdentificationCode.Phone => "12",
            IdentificationCode.UCSCode => "13",
            IdentificationCode.DunsPlusSuffix => "14",
            IdentificationCode.PetroleumAccountantsSocietyOfCanadaCode => "15",
            IdentificationCode.DunsNumberWith4CharSuffix => "16",
            IdentificationCode.ABARoutingNumber => "17",
            IdentificationCode.AARStandardDistributionCode => "18",
            IdentificationCode.EDICACommIDNumber => "19",
            IdentificationCode.HealthIndustryNumber => "20",
            IdentificationCode.IPEDS => "21",
            IdentificationCode.FICE => "22",
            IdentificationCode.NCESCommonCoreNumber => "23",
            IdentificationCode.CollegeBoardATPCode => "24",
            IdentificationCode.ACTCode => "25",
            IdentificationCode.StatisticsCanadaPostsecondaryList => "26",
            IdentificationCode.CMSCarrierIdentificationNumber => "27",
            IdentificationCode.CMSFiscalIntermediaryIdentificationNumber => "28",
            IdentificationCode.CMSMedicareProviderSupplierNumber => "29",
            IdentificationCode.USFederalTaxIdentificationNumber => "30",
            IdentificationCode.IAIABCJurisdictionIdentificationNumberPlus4 => "31",
            IdentificationCode.USFEIN => "32",
            IdentificationCode.NAICCompanyCode => "33",
            IdentificationCode.MedicaidProviderSupplierNumber => "34",
            IdentificationCode.StatisticsCanadaCollegeStudentInfoSystemCode => "35",
            IdentificationCode.StatisticsCanadaUniversityStudentInfoSystemCode => "36",
            IdentificationCode.SocietyOfPropertyInfoCompilersAndAnalysts => "37",
            IdentificationCode.CollegeBoardACTSecondaryInstitutionCode => "38",
            IdentificationCode.AMECOPCommunicationID => "AM",
            IdentificationCode.NRMAAssigned => "NR",
            IdentificationCode.SAFERUserIdentificationNumber => "SA",
            IdentificationCode.StandardAddressNumber => "SN",
            IdentificationCode.MutuallyDefined => "ZZ",
            _ => null
        };
    }

    public static IdentificationCode? StringToEnum(this string? value)
    {
        return value switch
        {
            "01" => IdentificationCode.Duns,
            "02" => IdentificationCode.SCAC,
            "03" => IdentificationCode.FMC,
            "04" => IdentificationCode.IATA,
            "07" => IdentificationCode.GLN,
            "08" => IdentificationCode.UCCEDICommID,
            "09" => IdentificationCode.X121,
            "10" => IdentificationCode.DoDActivityAddressCode,
            "11" => IdentificationCode.DEA,
            "12" => IdentificationCode.Phone,
            "13" => IdentificationCode.UCSCode,
            "14" => IdentificationCode.DunsPlusSuffix,
            "15" => IdentificationCode.PetroleumAccountantsSocietyOfCanadaCode,
            "16" => IdentificationCode.DunsNumberWith4CharSuffix,
            "17" => IdentificationCode.ABARoutingNumber,
            "18" => IdentificationCode.AARStandardDistributionCode,
            "19" => IdentificationCode.EDICACommIDNumber,
            "20" => IdentificationCode.HealthIndustryNumber,
            "21" => IdentificationCode.IPEDS,
            "22" => IdentificationCode.FICE,
            "23" => IdentificationCode.NCESCommonCoreNumber,
            "24" => IdentificationCode.CollegeBoardATPCode,
            "25" => IdentificationCode.ACTCode,
            "26" => IdentificationCode.StatisticsCanadaPostsecondaryList,
            "27" => IdentificationCode.CMSCarrierIdentificationNumber,
            "28" => IdentificationCode.CMSFiscalIntermediaryIdentificationNumber,
            "29" => IdentificationCode.CMSMedicareProviderSupplierNumber,
            "30" => IdentificationCode.USFederalTaxIdentificationNumber,
            "31" => IdentificationCode.IAIABCJurisdictionIdentificationNumberPlus4,
            "32" => IdentificationCode.USFEIN,
            "33" => IdentificationCode.NAICCompanyCode,
            "34" => IdentificationCode.MedicaidProviderSupplierNumber,
            "35" => IdentificationCode.StatisticsCanadaCollegeStudentInfoSystemCode,
            "36" => IdentificationCode.StatisticsCanadaUniversityStudentInfoSystemCode,
            "37" => IdentificationCode.SocietyOfPropertyInfoCompilersAndAnalysts,
            "38" => IdentificationCode.CollegeBoardACTSecondaryInstitutionCode,
            "AM" => IdentificationCode.AMECOPCommunicationID,
            "NR" => IdentificationCode.NRMAAssigned,
            "SA" => IdentificationCode.SAFERUserIdentificationNumber,
            "SN" => IdentificationCode.StandardAddressNumber,
            "ZZ" => IdentificationCode.MutuallyDefined,
            _ => null
        };
    }

    public static IsOneOfValuesAttribute CreateIdentificationCodeAttribute()
    {
        var validCodes = Enum.GetValues(typeof(IdentificationCode))
            .Cast<IdentificationCode>()
            .Select(code => code.EnumToString())
            .Where(code => code is { Length: 2 })
            .OfType<string>()
            .ToArray();

        return new IsOneOfValuesAttribute(ValidationSeverity.Error, 5, 0, validCodes);
    }
}

================
File: EdiSource.Domain/Standard/Loops/ISA/InterchangeEnvelope.cs
================
using System.Threading.Channels;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Standard.Segments;

namespace EdiSource.Domain.Standard.Loops.ISA;

public sealed class InterchangeEnvelope : IEdi<InterchangeEnvelope>, ISegmentIdentifier<InterchangeEnvelope>,
    ISegmentIdentifier<Segments.ISA>, ILoopInitialize<InterchangeEnvelope, InterchangeEnvelope>
{
    public static List<TransactionSetDefinition> TransactionSetDefinitions = [];

    public Segments.ISA ISA { get; set; } = default!;

    public LoopList<FunctionalGroup> FunctionalGroups { get; } = [];

    public IEA IEA { get; set; } = default!;

    public InterchangeEnvelope? Parent
    {
        get => null;
        set => _ = value;
    }

    public List<IEdi?> EdiItems => [ISA, FunctionalGroups, IEA];

    public static Task<InterchangeEnvelope> InitializeAsync(ChannelReader<Segment> segmentReader, ILoop? parent)
    {
        if (parent is null) return InitializeAsync(segmentReader, null);

        if (parent is not InterchangeEnvelope typedParent)
            throw new ArgumentException($"Parent must be of type {nameof(InterchangeEnvelope)}");

        return InitializeAsync(segmentReader, typedParent);
    }

    public static async Task<InterchangeEnvelope> InitializeAsync(ChannelReader<Segment> segmentReader,
        InterchangeEnvelope? parent)
    {
        var loop = new InterchangeEnvelope();

        loop.ISA = await SegmentLoopFactory<Segments.ISA, InterchangeEnvelope>.CreateAsync(segmentReader, loop);

        while (await segmentReader.WaitToReadAsync())
        {
            if (await ISegmentIdentifier<FunctionalGroup>.MatchesAsync(segmentReader))
            {
                loop.FunctionalGroups.Add(await FunctionalGroup.InitializeAsync(segmentReader, loop));
                continue;
            }

            break;
        }

        loop.IEA = await SegmentLoopFactory<IEA, InterchangeEnvelope>.CreateAsync(segmentReader, loop);

        return loop;
    }

    public static EdiId EdiId => Segments.ISA.EdiId;
}

================
File: EdiSource.Domain/Standard/Loops/FunctionalGroup.cs
================
using System.Threading.Channels;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Standard.Loops.ISA;
using EdiSource.Domain.Standard.Segments;
using EdiSource.Domain.Structure.GenericTransactionSetData;

namespace EdiSource.Domain.Standard.Loops;

public sealed class FunctionalGroup : IEdi<InterchangeEnvelope>, ISegmentIdentifier<FunctionalGroup>,
    ISegmentIdentifier<GS>, ILoopInitialize<InterchangeEnvelope, FunctionalGroup>
{
    private static readonly EdiId _st = new("ST");

    public GS GS { get; set; } = default!;

    public LoopList<ILoop> TransactionSets { get; } = [];

    public GE GE { get; set; } = default!;

    public InterchangeEnvelope? Parent { get; set; }
    public List<IEdi?> EdiItems => [GS, TransactionSets, GE];

    public static Task<FunctionalGroup> InitializeAsync(ChannelReader<Segment> segmentReader, ILoop? parent)
    {
        if (parent is null) return InitializeAsync(segmentReader, null);

        if (parent is not InterchangeEnvelope typedParent)
            throw new ArgumentException($"Parent must be of type {nameof(InterchangeEnvelope)}");

        return InitializeAsync(segmentReader, typedParent);
    }

    public static async Task<FunctionalGroup> InitializeAsync(ChannelReader<Segment> segmentReader,
        InterchangeEnvelope? parent)
    {
        var loop = new FunctionalGroup
        {
            Parent = parent
        };

        loop.GS = await SegmentLoopFactory<GS, FunctionalGroup>.CreateAsync(segmentReader, loop);

        while (await segmentReader.WaitToReadAsync())
        {
            if (!segmentReader.TryPeek(out var segment)) break;

            if (!_st.MatchesSegment(segment)) break;

            if (await CreateTransactionSet(segmentReader, segment, loop)) continue;

            break;
        }

        loop.GE = await SegmentLoopFactory<GE, FunctionalGroup>.CreateAsync(segmentReader, loop);

        return loop;
    }

    public static EdiId EdiId => GS.EdiId;

    private static async Task<bool> CreateTransactionSet(ChannelReader<Segment> segmentReader, Segment segment,
        FunctionalGroup loop)
    {
        foreach (var ts in InterchangeEnvelope.TransactionSetDefinitions)
        {
            var reader = ts(segment);
            if (reader is null) continue;

            loop.TransactionSets.Add(await reader(segmentReader, loop));
            return true;
        }

        var generic = GenericTransactionSet.Definition(segment);
        if (generic is null) return false;

        loop.TransactionSets.Add(await generic(segmentReader, loop));
        return true;
    }
}

================
File: EdiSource.Domain/Standard/Loops/ITransactionSet.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Loop.Extensions;
using EdiSource.Domain.Standard.Segments;
using EdiSource.Domain.Standard.Segments.STData;

namespace EdiSource.Domain.Standard.Loops;

public interface ITransactionSet<TSelf> : ILoop
    where TSelf : ITransactionSet<TSelf>,
    IEdi<FunctionalGroup>,
    ILoopInitialize<FunctionalGroup, TSelf>,
    ISegmentIdentifier<TSelf>
{
    static TransactionSetDefinition Definition =>
        TransactionSetDefinitionsFactory<TSelf>.CreateDefinition();

    public int GetTransactionSetSegmentCount()
    {
        return this.CountSegments();
    }

    public string GetTransactionSetControlNumber()
    {
        var segment = EdiItems.FirstOrDefault(x => x is ST<TSelf>) as ST<TSelf>;

        if (segment is null)
            throw new NotSupportedException("Must have ST segment");

        return segment.TransactionSetControlNumber;
    }
}

================
File: EdiSource.Domain/Standard/Loops/TransactionSetDefinition.cs
================
using System.Threading.Channels;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;

namespace EdiSource.Domain.Standard.Loops;

public delegate Func<ChannelReader<Segment>, FunctionalGroup, Task<ILoop>>?
    TransactionSetDefinition(Segment id);

public static class TransactionSetDefinitionsFactory<T>
    where T : ILoop, ILoopInitialize<FunctionalGroup, T>, ISegmentIdentifier<T>
{
    public static TransactionSetDefinition CreateDefinition()
    {
        return id =>
        {
            if (!T.EdiId.MatchesSegment(id)) return null;

            return (segmentReader, parent) =>
                T.InitializeAsync(segmentReader, parent).ContinueWith(ILoop (x) => x.Result);
        };
    }
}

================
File: EdiSource.Domain/Standard/Segments/DTPData/DateFormatCode.cs
================
namespace EdiSource.Domain.Standard.Segments.DTPData;

public enum DateFormatCode
{
    CC, // First Two Digits of Year Expressed in Format CCYY
    CD, // Month and Year Expressed in Format MMMYYYY
    CM, // Date in Format CCYYMM
    CQ, // Date in Format CCYYQ
    CY, // Year Expressed in Format CCYY
    D6, // Date Expressed in Format YYMMDD
    D8, // Date Expressed in Format CCYYMMDD
    DA, // Range of Dates within a Single Month Expressed in Format DD-DD
    DB, // Date Expressed in Format MMDDCCYY
    DD, // Day of Month in Numeric Format
    DDT, // Range of Dates and Time, Expressed in CCYYMMDD-CCYYMMDDHHMM
    DT, // Date and Time Expressed in Format CCYYMMDDHHMM
    DTD, // Range of Dates and Time, Expressed in CCYYMMDDHHMM-CCYYMMDD
    DTS, // Range of Date and Time Expressed in Format CCYYMMDDHHMMSS-CCYYMMDDHHMMSS
    EH, // Last Digit of Year and Julian Date Expressed in Format YDDD
    KA, // Date Expressed in Format YYMMMDD
    MCY, // MMCCYY
    MD, // Month of Year and Day of Month Expressed in Format MMDD
    MM, // Month of Year in Numeric Format
    RD, // Range of Dates Expressed in Format MMDDCCYY-MMDDCCYY
    RD2, // Range of Years Expressed in Format YY-YY
    RD4, // Range of Years Expressed in Format CCYY-CCYY
    RD5, // Range of Years and Months Expressed in Format CCYYMM-CCYYMM
    RD6, // Range of Dates Expressed in Format YYMMDD-YYMMDD
    RD8, // Range of Dates Expressed in Format CCYYMMDD-CCYYMMDD
    RDM, // Range of Dates Expressed in Format YYMMDD-MMDD
    RDT, // Range of Date and Time, Expressed in Format CCYYMMDDHHMM-CCYYMMDDHHMM
    RMD, // Range of Months and Days Expressed in Format MMDD-MMDD
    RMY, // Range of Years and Months Expressed in Format YYMM-YYMM
    RTM, // Range of Time Expressed in Format HHMM-HHMM
    RTS, // Date and Time Expressed in Format CCYYMMDDHHMMSS
    TC, // Julian Date Expressed in Format DDD
    TM, // Time Expressed in Format HHMM
    TQ, // Date Expressed in Format MMYY
    TR, // Date and Time Expressed in Format DDMMYYHHMM
    TS, // Time Expressed in Format HHMMSS
    TT, // Date Expressed in Format MMDDYY
    TU, // Date Expressed in Format YYDDD
    UN, // Unstructured
    YM, // Year and Month Expressed in Format YYMM
    YMM, // Range of Year and Months, Expressed in CCYYMMM-MMM Format
    YY // Last Two Digits of Year Expressed in Format CCYY
}

================
File: EdiSource.Domain/Standard/Segments/DTPData/DateFormatMapper.cs
================
using System.Globalization;

namespace EdiSource.Domain.Standard.Segments.DTPData;

public static class DateFormatMapper
{
    private static readonly Dictionary<DateFormatCode, (string, string?)> _formatMap =
        new()
        {
            { DateFormatCode.CC, ("yy", null) },
            { DateFormatCode.CD, ("MMMYYYY", null) },
            { DateFormatCode.CM, ("yyyyMM", null) },
            { DateFormatCode.CQ, ("yyyy'Q'q", null) },
            { DateFormatCode.CY, ("yyyy", null) },
            { DateFormatCode.D6, ("yyMMdd", null) },
            { DateFormatCode.D8, ("yyyyMMdd", null) },
            { DateFormatCode.DA, ("dd", "dd") },
            { DateFormatCode.DB, ("MMddyyyy", null) },
            { DateFormatCode.DD, ("dd", null) },
            { DateFormatCode.DDT, ("yyyyMMdd", "yyyyMMddHHmm") },
            { DateFormatCode.DT, ("yyyyMMddHHmm", null) },
            { DateFormatCode.DTD, ("yyyyMMddHHmm", "yyyyMMdd") },
            { DateFormatCode.DTS, ("yyyyMMddHHmmss", "yyyyMMddHHmmss") },
            { DateFormatCode.EH, ("yDDD", null) },
            { DateFormatCode.KA, ("yyMMMdd", null) },
            { DateFormatCode.MCY, ("MMyyyy", null) },
            { DateFormatCode.MD, ("MMdd", null) },
            { DateFormatCode.MM, ("MM", null) },
            { DateFormatCode.RD, ("MMddyyyy", "MMddyyyy") },
            { DateFormatCode.RD2, ("yy", "yy") },
            { DateFormatCode.RD4, ("yyyy", "yyyy") },
            { DateFormatCode.RD5, ("yyyyMM", "yyyyMM") },
            { DateFormatCode.RD6, ("yyMMdd", "yyMMdd") },
            { DateFormatCode.RD8, ("yyyyMMdd", "yyyyMMdd") },
            { DateFormatCode.RDM, ("yyMMdd", "MMdd") },
            { DateFormatCode.RDT, ("yyyyMMddHHmm", "yyyyMMddHHmm") },
            { DateFormatCode.RMD, ("MMdd", "MMdd") },
            { DateFormatCode.RMY, ("yyMM", "yyMM") },
            { DateFormatCode.RTM, ("HHmm", "HHmm") },
            { DateFormatCode.RTS, ("yyyyMMddHHmmss", null) },
            { DateFormatCode.TC, ("DDD", null) },
            { DateFormatCode.TM, ("HHmm", null) },
            { DateFormatCode.TQ, ("MMyy", null) },
            { DateFormatCode.TR, ("ddMMyyHHmm", null) },
            { DateFormatCode.TS, ("HHmmss", null) },
            { DateFormatCode.TT, ("MMddyy", null) },
            { DateFormatCode.TU, ("yyDDD", null) },
            { DateFormatCode.UN, ("", null) }, // Unstructured format
            { DateFormatCode.YM, ("yyMM", null) },
            { DateFormatCode.YMM, ("yyyyMMM", "MMM") },
            { DateFormatCode.YY, ("yy", null) }
        };

    public static (string, string?) GetFormat(DateFormatCode code)
    {
        if (_formatMap.TryGetValue(code, out var format)) return format;

        throw new ArgumentException($"No format string found for DateFormatCode: {code}");
    }

    public static DateFormatCode? GetCodeFromFormat(string format)
    {
        foreach (var kvp in _formatMap)
            if (kvp.Value.Item1 == format ||
                (kvp.Value.Item2 != null && $"{kvp.Value.Item1}-{kvp.Value.Item2}" == format))
                return kvp.Key;

        return null;
    }

    public static (DateTime, DateTime?) CreateDateTime(string dateString, string? endDateString = null)
    {
        DateTime startDate;
        DateTime? endDate = null;

        // Try parsing with all available formats
        foreach (var formatTuple in _formatMap.Values)
            if (TryParseDateTime(dateString, formatTuple.Item1, out startDate))
            {
                if (endDateString != null && formatTuple.Item2 != null)
                {
                    if (TryParseDateTime(endDateString, formatTuple.Item2, out var parsedEndDate))
                    {
                        endDate = parsedEndDate;
                    }
                    else
                    {
                        // If end date doesn't parse with the matching format, try parsing it with the start format
                        if (TryParseDateTime(endDateString, formatTuple.Item1, out parsedEndDate))
                            endDate = parsedEndDate;
                    }
                }

                return (startDate, endDate);
            }

        throw new FormatException($"Unable to parse the date string: {dateString}");
    }

    private static bool TryParseDateTime(string dateString, string format, out DateTime result)
    {
        return DateTime.TryParseExact(dateString, format, CultureInfo.InvariantCulture, DateTimeStyles.None,
            out result);
    }
}

================
File: EdiSource.Domain/Standard/Segments/DTPData/DTP.cs
================
using EdiSource.Domain.Segments;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;
using EdiSource.Domain.Validation.SourceGeneration;

namespace EdiSource.Domain.Standard.Segments.DTPData;

public class DTP : Segment, IValidatable, ISourceGeneratorValidatable
{
    public string Qualifier
    {
        get => GetCompositeElement(1);
        set => SetCompositeElement(value, 1);
    }

    public DateFormatCode DateFormatCode
    {
        get => this.GetEnumRequired<DateFormatCode>(2);
        set => this.SetEnum(value, 2);
    }

    public (string Date, string? DateRange) DateFormats => DateFormatMapper.GetFormat(DateFormatCode);

    public DateTime Date
    {
        get => this.GetDateRequired(3, format: DateFormats.Date);
        set => this.SetDate(value, 3, format: DateFormats.Date);
    }

    public DateTime? DateEnd
    {
        get => DateFormats.DateRange?
            .Map(format => this.GetDate(3, 1, format));
        set => DateFormats.DateRange?
            .Map(format => this.SetDate(value, 3, 1, format));
    }

    public List<IIndirectValidatable> SourceGenValidations { get; } =
    [
        new IsOneOfValuesAttribute(ValidationSeverity.Critical, 0, 0, "DTP"),
        new RequiredDataElementsAttribute(ValidationSeverity.Critical, [0, 1, 2]),
        new BeDateTimeAttribute(ValidationSeverity.Critical, 3, 0),
        new BeDateTimeAttribute(ValidationSeverity.Critical, 3, 1),
        new ElementLengthAttribute(ValidationSeverity.Critical, 1, 3),
        new ElementLengthAttribute(ValidationSeverity.Critical, 2, 3),
        new ElementLengthAttribute(ValidationSeverity.Critical, 3, 35)
    ];

    public IEnumerable<ValidationMessage> Validate()
    {
        return [ValidationFactory.CreateCritical(this, "Fuck")];
    }
}

================
File: EdiSource.Domain/Standard/Segments/STData/ST.cs
================
using EdiSource.Domain.Helper;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.SourceGeneration;

namespace EdiSource.Domain.Standard.Segments.STData;

public abstract class ST<T> : Segment, IEdi<T>, ISourceGeneratorValidatable
    where T : IEdi
{
    public abstract T? Parent { get; set; }

    public TransactionSetIdentifierCode TransactionSetIdentifierCode
    {
        get => this.GetEnumRequired<TransactionSetIdentifierCode>(1);
        set => this.SetEnum(value, 1);
    }

    public string TransactionSetControlNumber
    {
        get => GetCompositeElement(2);
        set => SetCompositeElement(value, 2);
    }

    public string? ImplementationConventionReference
    {
        get => GetCompositeElementOrNull(3);
        set => value.DoIfNotNull(x => SetCompositeElement(x, 3));
    }

    public List<IIndirectValidatable> SourceGenValidations { get; } =
    [
        new RequiredDataElementsAttribute(ValidationSeverity.Critical, [0, 1, 2]),
        new IsOneOfValuesAttribute(ValidationSeverity.Critical, 0, 0, "ST"),
        new IsOneOfValuesAttribute(ValidationSeverity.Critical, 1, 0,
            EnumExtensions.EnumToStringArray<TransactionSetIdentifierCode>())
    ];
}

================
File: EdiSource.Domain/Standard/Segments/STData/TransactionSetIdentifierCode.cs
================
namespace EdiSource.Domain.Standard.Segments.STData;

public enum TransactionSetIdentifierCode
{
    _100,
    _101,
    _102,
    _103,
    _104,
    _105,
    _106,
    _107,
    _108,
    _109,
    _110,
    _111,
    _112,
    _113,
    _120,
    _121,
    _124,
    _125,
    _126,
    _127,
    _128,
    _129,
    _130,
    _131,
    _132,
    _133,
    _135,
    _138,
    _139,
    _140,
    _141,
    _142,
    _143,
    _144,
    _146,
    _147,
    _148,
    _149,
    _150,
    _151,
    _152,
    _153,
    _154,
    _155,
    _157,
    _158,
    _159,
    _160,
    _161,
    _163,
    _170,
    _175,
    _176,
    _179,
    _180,
    _185,
    _186,
    _187,
    _188,
    _189,
    _190,
    _191,
    _194,
    _195,
    _196,
    _197,
    _198,
    _199,
    _200,
    _201,
    _202,
    _203,
    _204,
    _205,
    _206,
    _210,
    _211,
    _212,
    _213,
    _214,
    _215,
    _216,
    _217,
    _219,
    _220,
    _222,
    _223,
    _224,
    _225,
    _227,
    _228,
    _240,
    _242,
    _244,
    _245,
    _248,
    _249,
    _250,
    _251,
    _252,
    _255,
    _256,
    _259,
    _260,
    _261,
    _262,
    _263,
    _264,
    _265,
    _266,
    _267,
    _268,
    _269,
    _270,
    _271,
    _272,
    _273,
    _274,
    _275,
    _276,
    _277,
    _278,
    _280,
    _283,
    _284,
    _285,
    _286,
    _288,
    _290,
    _300,
    _301,
    _303,
    _304,
    _309,
    _310,
    _311,
    _312,
    _313,
    _315,
    _317,
    _319,
    _322,
    _323,
    _324,
    _325,
    _326,
    _350,
    _352,
    _353,
    _354,
    _355,
    _356,
    _357,
    _358,
    _359,
    _361,
    _362,
    _404,
    _410,
    _412,
    _414,
    _417,
    _418,
    _419,
    _420,
    _421,
    _422,
    _423,
    _424,
    _425,
    _426,
    _429,
    _431,
    _432,
    _433,
    _434,
    _435,
    _436,
    _437,
    _440,
    _451,
    _452,
    _453,
    _455,
    _456,
    _460,
    _463,
    _466,
    _468,
    _470,
    _475,
    _485,
    _486,
    _490,
    _492,
    _494,
    _500,
    _501,
    _503,
    _504,
    _511,
    _517,
    _521,
    _527,
    _536,
    _540,
    _561,
    _567,
    _568,
    _601,
    _603,
    _620,
    _625,
    _650,
    _715,
    _753,
    _754,
    _805,
    _806,
    _810,
    _811,
    _812,
    _813,
    _814,
    _815,
    _816,
    _818,
    _819,
    _820,
    _821,
    _822,
    _823,
    _824,
    _826,
    _827,
    _828,
    _829,
    _830,
    _831,
    _832,
    _833,
    _834,
    _835,
    _836,
    _837,
    _838,
    _839,
    _840,
    _841,
    _842,
    _843,
    _844,
    _845,
    _846,
    _847,
    _848,
    _849,
    _850,
    _851,
    _852,
    _853,
    _854,
    _855,
    _856,
    _857,
    _858,
    _859,
    _860,
    _861,
    _862,
    _863,
    _864,
    _865,
    _866,
    _867,
    _868,
    _869,
    _870,
    _871,
    _872,
    _873,
    _874,
    _875,
    _876,
    _877,
    _878,
    _879,
    _880,
    _881,
    _882,
    _883,
    _884,
    _885,
    _886,
    _887,
    _888,
    _889,
    _890,
    _891,
    _892,
    _893,
    _894,
    _895,
    _896,
    _897,
    _920,
    _924,
    _925,
    _926,
    _928,
    _940,
    _943,
    _944,
    _945,
    _947,
    _980,
    _990,
    _993,
    _996,
    _997,
    _998,
    _999
}

================
File: EdiSource.Domain/Standard/Segments/GE.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Standard.Loops;

namespace EdiSource.Domain.Standard.Segments;

public sealed class GE : Segment, IEdi<FunctionalGroup>, ISegmentIdentifier<GE>, IRefresh
{
    public int E01NumberOfTransactionSets
    {
        get => Parent is null
            ? this.GetIntRequired(1)
            : Parent.TransactionSets.Count
                .Do(x => this.SetInt(x, 1));
        set => this.SetInt(value, 1);
    }

    public string E02GroupControlNumber
    {
        get => Parent is null
            ? GetCompositeElement(2)
            : Parent.GS.E06GroupControlNumber
                .Do(x => SetCompositeElement(x, 2));
        set => SetCompositeElement(value, 2);
    }

    public FunctionalGroup? Parent { get; set; }

    public void Refresh()
    {
        _ = E01NumberOfTransactionSets;
        _ = E02GroupControlNumber;
    }

    public static EdiId EdiId { get; } = new("GE");
}

================
File: EdiSource.Domain/Standard/Segments/GenericSegment.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Standard.Loops;

namespace EdiSource.Domain.Standard.Segments;

public sealed class GenericSegment<T> : Segment, IEdi<T> where T : IEdi
{
    public T? Parent { get; set; }
}

================
File: EdiSource.Domain/Standard/Segments/GS.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Standard.Loops;

namespace EdiSource.Domain.Standard.Segments;

public sealed class GS : Segment, IEdi<FunctionalGroup>, ISegmentIdentifier<GS>
{
    public string E06GroupControlNumber
    {
        get => GetCompositeElement(6);
        set => SetCompositeElement(value, 6);
    }

    public FunctionalGroup? Parent { get; set; }

    public static EdiId EdiId { get; } = new("GS");
}

================
File: EdiSource.Domain/Standard/Segments/IEA.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Standard.Loops.ISA;

namespace EdiSource.Domain.Standard.Segments;

public sealed class IEA : Segment, IEdi<InterchangeEnvelope>, ISegmentIdentifier<IEA>, IRefresh
{
    public int E01NumberOfFunctionalGroups
    {
        get => Parent is null
            ? this.GetIntRequired(1)
            : Parent.FunctionalGroups.Count
                .Do(x => this.SetInt(x, 1));
        set => this.SetInt(value, 1);
    }

    public string E02InterchangeControlNumber
    {
        get => Parent is null
            ? GetCompositeElement(2)
            : Parent.ISA.InterchangeControlNumber
                .Do(x => SetCompositeElement(x, 2));
        set => SetCompositeElement(value, 2);
    }

    public InterchangeEnvelope? Parent { get; set; }
    public static EdiId EdiId { get; } = new("IEA");
    public void Refresh()
    {
        _ = E01NumberOfFunctionalGroups;
        _ = E02InterchangeControlNumber;
    }
}

================
File: EdiSource.Domain/Standard/Segments/IRefresh.cs
================
namespace EdiSource.Domain.Standard.Segments;

public interface IRefresh
{
    void Refresh();
}

================
File: EdiSource.Domain/Standard/Segments/ISA.cs
================
using EdiSource.Domain.Elements;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Separator;
using EdiSource.Domain.Standard.Loops.ISA;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.SourceGeneration;

namespace EdiSource.Domain.Standard.Segments;

public sealed class ISA : Segment, IEdi<InterchangeEnvelope>, ISegmentIdentifier<ISA>, ISourceGeneratorValidatable
{
    public InterchangeEnvelope? Parent { get; set; }
    public static EdiId EdiId { get; } = new("ISA");

    public List<IIndirectValidatable> SourceGenValidations { get; } =
    [
        new RequiredDataElementsAttribute(ValidationSeverity.Critical,
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]),
        new ElementLengthAttribute(ValidationSeverity.Critical, 0, 3),
        new ElementLengthAttribute(ValidationSeverity.Critical, 1, 2),
        new IsOneOfValuesAttribute(ValidationSeverity.Error, 1, 0, "00", "01", "02", "03", "04", "05", "06", "07",
            "08"),
        new ElementLengthAttribute(ValidationSeverity.Critical, 2, 10),
        new ElementLengthAttribute(ValidationSeverity.Critical, 3, 2),
        new IsOneOfValuesAttribute(ValidationSeverity.Error, 3, 0, "00", "01"),
        new ElementLengthAttribute(ValidationSeverity.Critical, 4, 10),
        new ElementLengthAttribute(ValidationSeverity.Critical, 5, 2),
        IdentificationCodeExtensions.CreateIdentificationCodeAttribute(),
        new ElementLengthAttribute(ValidationSeverity.Critical, 6, 15),
        new ElementLengthAttribute(ValidationSeverity.Critical, 7, 2),
        new ElementLengthAttribute(ValidationSeverity.Critical, 8, 15),
        new ElementLengthAttribute(ValidationSeverity.Critical, 9, 6),
        new BeDateAttribute(ValidationSeverity.Critical, 9, 0, "yyMMdd"),
        new ElementLengthAttribute(ValidationSeverity.Critical, 10, 4),
        new BeTimeAttribute(ValidationSeverity.Critical, 10, 4),
        new ElementLengthAttribute(ValidationSeverity.Critical, 11, 1),
        new ElementLengthAttribute(ValidationSeverity.Critical, 12, 5),
        new ElementLengthAttribute(ValidationSeverity.Critical, 13, 9),
        new ElementLengthAttribute(ValidationSeverity.Critical, 14, 1),
        new ElementLengthAttribute(ValidationSeverity.Critical, 15, 1),
        new ElementLengthAttribute(ValidationSeverity.Critical, 16, 1)
    ];

    private const int SegmentExpectedElementCount = 16;


    public ISA()
    {
    }

    public ISA(Segment segment) : base(segment)
    {
        ValidateElementCount();
    }

    public ISA(string segmentText, Separators? separators = null) : base(segmentText, separators)
    {
        ValidateElementCount();
    }

    public ISA(IEnumerable<Element>? elements = null, Separators? separators = null) : base(elements, separators)
    {
        ValidateElementCount();
    }

    private void ValidateElementCount()
    {
        if (Elements.Count != SegmentExpectedElementCount)
        {
            throw new ArgumentException(
                $"ISA segment must contain exactly {SegmentExpectedElementCount} elements. Found {Elements.Count} elements.");
        }
    }

    private string ValidateAndPadField(string value, int requiredLength, string fieldName)
    {
        if (value.Length > requiredLength)
            throw new ArgumentException(
                $"{fieldName} must be {requiredLength} characters or less. Found {value.Length} characters.");

        return value.PadRight(requiredLength);
    }

    // ISA-01: Authorization Information Qualifier (I01)
    public string AuthorizationInformationQualifier
    {
        get => this[0];
        set => this[0] = ValidateAndPadField(value, 2, "Authorization Information Qualifier");
    }

    // ISA-02: Authorization Information (I02)
    public string AuthorizationInformation
    {
        get => this[1];
        set => this[1] = ValidateAndPadField(value, 10, "Authorization Information");
    }

    // ISA-03: Security Information Qualifier (I03)
    public string SecurityInformationQualifier
    {
        get => this[2];
        set => this[2] = ValidateAndPadField(value, 2, "Security Information Qualifier");
    }

    // ISA-04: Security Information (I04)
    public string SecurityInformation
    {
        get => this[3];
        set => this[3] = ValidateAndPadField(value, 10, "Security Information");
    }

    // ISA-05: Interchange ID Qualifier (I05)
    public string InterchangeSenderQualifier
    {
        get => this[4];
        set => this[4] = ValidateAndPadField(value, 2, "Interchange Sender Qualifier");
    }

    // ISA-06: Interchange Sender ID (I06)
    public string InterchangeSenderId
    {
        get => this[5];
        set => this[5] = ValidateAndPadField(value, 15, "Interchange Sender ID");
    }

    // ISA-07: Interchange ID Qualifier (I05)
    public string InterchangeReceiverQualifier
    {
        get => this[6];
        set => this[6] = ValidateAndPadField(value, 2, "Interchange Receiver Qualifier");
    }

    // ISA-08: Interchange Receiver ID (I07)
    public string InterchangeReceiverId
    {
        get => this[7];
        set => this[7] = ValidateAndPadField(value, 15, "Interchange Receiver ID");
    }

    // ISA-09: Interchange Date (I08)
    public DateTime InterchangeDate
    {
        get => DateTime.ParseExact(this[8], "yyMMdd", null);
        set => this[8] = value.ToString("yyMMdd");
    }

    // ISA-10: Interchange Time (I09)
    public TimeSpan InterchangeTime
    {
        get => TimeSpan.ParseExact(this[9], "HHmm", null);
        set => this[9] = value.ToString("HHmm");
    }

    // ISA-11: Repetition Separator (I65)
    public char RepetitionSeparator
    {
        get => this[10][0];
        set => this[10] = value.ToString();
    }

    // ISA-12: Interchange Control Version Number (I11)
    public string InterchangeControlVersionNumber
    {
        get => this[11];
        set => this[11] = ValidateAndPadField(value, 5, "Interchange Control Version Number");
    }

    // ISA-13: Interchange Control Number (I12)
    public string InterchangeControlNumber
    {
        get => this[12];
        set => this[12] = value.PadLeft(9, '0');
    }

    // ISA-14: Acknowledgment Requested (I13)
    public string AcknowledgmentRequested
    {
        get => this[13];
        set => this[13] = ValidateAndPadField(value, 1, "Acknowledgment Requested");
    }

    // ISA-15: Usage Indicator (I14)
    public string UsageIndicator
    {
        get => this[14];
        set => this[14] = ValidateAndPadField(value, 1, "Usage Indicator");
    }

    // ISA-16: Component Element Separator (I15)
    public char ComponentElementSeparator
    {
        get => this[15][0];
        set => this[15] = value.ToString();
    }

    /// <summary>
    /// Creates a new ISA segment with default values
    /// </summary>
    public static ISA CreateDefault(
        string senderQualifier,
        string senderId,
        string receiverQualifier,
        string receiverId,
        int controlNumber,
        string usageIndicator = "P",
        string acknowledgmentRequested = "0",
        string version = "00501")
    {
        var elements = new List<Element>
        {
            new(["00"]), // ISA-01: Authorization Information Qualifier
            new(["          "]), // ISA-02: Authorization Information
            new(["00"]), // ISA-03: Security Information Qualifier
            new(["          "]), // ISA-04: Security Information
            new([senderQualifier]), // ISA-05: Interchange ID Qualifier
            new([senderId]), // ISA-06: Interchange Sender ID
            new([receiverQualifier]), // ISA-07: Interchange ID Qualifier
            new([receiverId]), // ISA-08: Interchange Receiver ID
            new([DateTime.Now.ToString("yyMMdd")]), // ISA-09: Interchange Date
            new([DateTime.Now.ToString("HHmm")]), // ISA-10: Interchange Time
            new(["^"]), // ISA-11: Repetition Separator
            new([version]), // ISA-12: Interchange Control Version Number
            new([controlNumber.ToString().PadLeft(9, '0')]), // ISA-13: Interchange Control Number
            new([acknowledgmentRequested]), // ISA-14: Acknowledgment Requested
            new([usageIndicator]), // ISA-15: Usage Indicator
            new([
                Separators.DefaultSeparators.CompositeElementSeparator.ToString()
            ]) // ISA-16: Component Element Separator
        };

        return new ISA(elements);
    }
}

================
File: EdiSource.Domain/Standard/Segments/REF.cs
================
using EdiSource.Domain.Elements;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;
using EdiSource.Domain.Validation.SourceGeneration;

namespace EdiSource.Domain.Standard.Segments;

public class REF : Segment, IValidatable, ISourceGeneratorValidatable
{
    public static EdiId EdiId { get; } = new("REF");

    public string E01Identifier
    {
        get => GetCompositeElement(1);
        set => SetCompositeElement(value, 1);
    }

    public string? E02Identification
    {
        get => GetCompositeElement(2, 2);
        set => value?.Do(x => SetCompositeElement(x, 1));
    }

    public Element? E03Description
    {
        get => GetElementOrNull(3);
        set => SetDataElement(3, values: [..value?.Select(x => x) ?? []]);
    }

    public List<IIndirectValidatable> SourceGenValidations { get; } =
    [
        new RequiredDataElementsAttribute(ValidationSeverity.Critical, [0, 1]),
        new IsOneOfValuesAttribute(ValidationSeverity.Critical, 0, 0, "REF"),
        new ElementLengthAttribute(ValidationSeverity.Critical, 1, 80),
        new ElementLengthAttribute(ValidationSeverity.Critical, 2, 80),
        new ElementLengthAttribute(ValidationSeverity.Critical, 2, 80),
        new ElementLengthAttribute(ValidationSeverity.Critical, 3, 80)
    ];

    public IEnumerable<ValidationMessage> Validate()
    {
        if (E02Identification is null && E03Description is null)
            yield return ValidationFactory.CreateError(this, "REF required either 2 or 3 elements");
    }
}

================
File: EdiSource.Domain/Standard/Segments/SE.cs
================
using System.Reflection.Emit;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Loop.Extensions;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Standard.Loops;

namespace EdiSource.Domain.Standard.Segments;

public abstract class SE<T> : Segment, IEdi<T>, IRefresh
    where T : ITransactionSet<T>, IEdi<FunctionalGroup>, ILoopInitialize<FunctionalGroup, T>, ISegmentIdentifier<T>
{
    public abstract T? Parent { get; set; }

    /// <summary>
    ///     If the parent exists then it will count the segments in the
    ///     transaction set, otherwise the value is from the segment itself.
    ///     If a parent does exist, the value will not update.
    /// </summary>
    public int E01NumberOfIncludedSegments
    {
        get
        {
            if (Parent is not ITransactionSet<T> ts)
                return this.GetIntRequired(1);

            var count = ts.GetTransactionSetSegmentCount();
            this.SetInt(count, 1);
            return count;
        }
        set => this.SetInt(value, 1);
    }

    /// <summary>
    ///     If the Parent exists it'll point to the Parent's ST's value,
    ///     otherwise it'll set the value directly on the segment
    /// </summary>
    public string E02TransactionSetControlNumber
    {
        get => Parent is not ITransactionSet<T> ts
            ? GetCompositeElement(2)
            : ts.GetTransactionSetControlNumber()
                .Do(x => SetCompositeElement(x, 2));
        set => SetCompositeElement(value, 2);
    }

    public void Refresh()
    {
        _ = E01NumberOfIncludedSegments;
        _ = E02TransactionSetControlNumber;
    }
}

================
File: EdiSource.Domain/Structure/GenericTransactionSetData/Generic_SE.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Standard.Segments;

namespace EdiSource.Domain.Structure.GenericTransactionSetData;

public sealed class Generic_SE : SE<GenericTransactionSet>, ISegmentIdentifier<Generic_SE>
{
    public override GenericTransactionSet? Parent { get; set; }
    public static EdiId EdiId { get; } = new("SE");
}

================
File: EdiSource.Domain/Structure/GenericTransactionSetData/Generic_ST.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Standard.Segments.STData;

namespace EdiSource.Domain.Structure.GenericTransactionSetData;

public sealed class Generic_ST : ST<GenericTransactionSet>, ISegmentIdentifier<Generic_ST>
{
    public override GenericTransactionSet? Parent { get; set; }
    public static EdiId EdiId { get; } = new("ST");
}

================
File: EdiSource.Domain/Structure/GenericTransactionSetData/GenericTransactionSet.cs
================
using System.Threading.Channels;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Loop.Extensions;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Standard.Loops;
using EdiSource.Domain.Standard.Segments;
using EdiSource.Domain.Standard.Segments.STData;

namespace EdiSource.Domain.Structure.GenericTransactionSetData;

/// <summary>
///     Used to serialize any transaction set.
///     This definition will be used if there are no other matching definitions.
/// </summary>
public sealed class GenericTransactionSet : IEdi<FunctionalGroup>, ISegmentIdentifier<GenericTransactionSet>,
    ISegmentIdentifier<Generic_ST>,
    ITransactionSet<GenericTransactionSet>, ILoopInitialize<FunctionalGroup, GenericTransactionSet>
{
    public Generic_ST ST { get; set; } = default!;

    public SegmentList<Segment> Segments { get; set; } = [];

    public Generic_SE SE { get; set; } = default!;

    public static Task<GenericTransactionSet> InitializeAsync(ChannelReader<Segment> segmentReader, ILoop? parent)
    {
        if (parent is null) return InitializeAsync(segmentReader, null);

        if (parent is not FunctionalGroup typedParent)
            throw new ArgumentException("Parent must be of type FunctionalGroup");

        return InitializeAsync(segmentReader, typedParent);
    }

    public static async Task<GenericTransactionSet> InitializeAsync(ChannelReader<Segment> segmentReader,
        FunctionalGroup? parent)
    {
        var loop = new GenericTransactionSet
        {
            Parent = parent
        };

        loop.ST = await SegmentLoopFactory<Generic_ST, GenericTransactionSet>.CreateAsync(segmentReader, loop);

        while (await segmentReader.WaitToReadAsync())
        {
            if (!await ISegmentIdentifier<Generic_SE>.MatchesAsync(segmentReader))
            {
                loop.Segments.Add(await segmentReader.ReadAsync());
                continue;
            }

            break;
        }

        loop.SE = await SegmentLoopFactory<Generic_SE, GenericTransactionSet>.CreateAsync(segmentReader, loop);

        return loop;
    }

    public static TransactionSetDefinition Definition { get; } =
        TransactionSetDefinitionsFactory<GenericTransactionSet>.CreateDefinition();

    public int GetTransactionSetSegmentCount()
    {
        return this.CountSegments();
    }

    public string GetTransactionSetControlNumber()
    {
        return ST.TransactionSetControlNumber;
    }

    public List<IEdi?> EdiItems => [ST, Segments, SE];

    public static EdiId EdiId { get; } = new("ST");
    public FunctionalGroup? Parent { get; set; }
}

================
File: EdiSource.Domain/Structure/BasicEdi.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.Structure;

/// <summary>
///     A non-typed edi structure with only segments and their seperator definition.
///     Can be used in cases where there is no edi implementation.
///     <br /><br />
///     Implements ILoop, so can be used in serialzation.
/// </summary>
/// <param name="segments"></param>
/// <param name="separators"></param>
public sealed class BasicEdi(IEnumerable<Segment> segments, Separators separators)
    : ILoop
{
    public List<Segment> Segments { get; } = segments.ToList();
    public Separators Separators { get; } = separators;

    public List<IEdi?> EdiItems => [..segments.Cast<IEdi?>()];

    public void Deconstruct(out List<Segment> outSegments, out Separators outSeparators)
    {
        outSegments = Segments;
        outSeparators = Separators;
    }
}

================
File: EdiSource.Domain/Structure/EdiTree.Create.cs
================
using EdiSource.Domain.Loop;
using EdiSource.Domain.Loop.Extensions;
using EdiSource.Domain.Segments.Extensions;
using EdiSource.Domain.Separator;

namespace EdiSource.Domain.Structure;

public sealed partial class EdiTree
{
    /// <summary>
    ///     Creates an EdiTree from the given loop with specified separators.
    /// </summary>
    /// <typeparam name="T">The type of the loop implementing ILoop interface.</typeparam>
    /// <param name="loop">The loop to be converted into an EdiTree.</param>
    /// <param name="node">Optional EdiTree node to accumulate the data. If null, a new tree node will be created.</param>
    /// <param name="separators">Optional separators to be used in EDI generation. If null, default separators will be used.</param>
    /// <param name="firstIteration">Flag indicating if this is the first call in the recursion chain.</param>
    /// <returns>The constructed EdiTree from the given loop.</returns>
    public static EdiTree Create<T>(T loop, EdiTree? node = null,
        Separators? separators = null, bool firstIteration = true)
        where T : ILoop
    {
        separators ??= Separators.DefaultSeparators;
        node ??= new EdiTree();

        if (firstIteration) node.Loop = typeof(T).Name;

        loop.EdiAction(x =>
            {
                var text = x.WriteToStringBuilder(separators: separators).ToString();
                node.Segments.Add(text);
            },
            segmentList =>
            {
                foreach (var text in segmentList
                             .Select(segment => segment.WriteToStringBuilder(separators: separators).ToString()))
                    node.Segments.Add(text);
            },
            loopL =>
            {
                var loopNode = new EdiTree
                {
                    Loop = loopL.GetType().Name
                };

                Create(loopL, loopNode, separators, false);
                node.Loops.Add(loopNode);
            },
            loopList =>
            {
                foreach (var loopL in loopList)
                {
                    var loopNode = new EdiTree
                    {
                        Loop = loopL.GetType().Name
                    };

                    Create(loopL, loopNode, separators, false);
                    node.Loops.Add(loopNode);
                }
            });

        return node;
    }
}

================
File: EdiSource.Domain/Structure/EdiTree.cs
================
namespace EdiSource.Domain.Structure;

/// <summary>
///     The EdiTree class represents the hierarchical structure of EDI data segments and loops.
///     It may have some use in instances where the edi data format needs conversion into another format,
///     like html.
/// </summary>
public sealed partial class EdiTree
{
    /// <summary>
    ///     Represents the name or identifier of the loop in the EDI tree structure.
    /// </summary>
    public string Loop { get; set; } = string.Empty;

    /// <summary>
    ///     Represents the collection of segments associated with the current EDI (Electronic Data Interchange) tree node.
    /// </summary>
    /// <remarks>
    ///     Each segment in the list is a string that follows the structured format of EDI segments,
    ///     which can include various types of data elements separated by defined separators.
    /// </remarks>
    public List<string> Segments { get; } = [];

    /// <summary>
    ///     Gets or sets the nested loops within the current loop structure.
    /// </summary>
    /// <remarks>
    ///     The <c>Loops</c> property is a list of <see cref="EdiTree" /> objects representing
    ///     the hierarchical nature of EDI loop structures. Each <see cref="EdiTree" /> object within
    ///     the <c>Loops</c> collection can contain its own child loops and segments.
    /// </remarks>
    public List<EdiTree> Loops { get; } = [];
}

================
File: EdiSource.Domain/Validation/Data/EdiValidationResult.cs
================
using System.Text;

namespace EdiSource.Domain.Validation.Data;

/// <summary>
///     A helper class that holds validation messages
/// </summary>
public class EdiValidationResult
{
    public bool IsValid => ValidationMessages.Any(x => x.Severity <= ValidationSeverity.Info);
    public bool HasWarning => ValidationMessages.Any(x => x.Severity >= ValidationSeverity.Warning);
    public bool HasError => ValidationMessages.Any(x => x.Severity >= ValidationSeverity.Error);
    public bool HasCritical => ValidationMessages.Any(x => x.Severity >= ValidationSeverity.Critical);

    public ValidationMessage[] WhereIsValid => ValidationMessages
        .Where(x => x.Severity <= ValidationSeverity.Info)
        .ToArray();

    public ValidationMessage[] WhereHasWarning => ValidationMessages
        .Where(x => x.Severity >= ValidationSeverity.Warning)
        .ToArray();

    public ValidationMessage[] WhereHasError => ValidationMessages
        .Where(x => x.Severity >= ValidationSeverity.Error)
        .ToArray();

    public ValidationMessage[] WhereHasCritical => ValidationMessages
        .Where(x => x.Severity >= ValidationSeverity.Critical)
        .ToArray();

    public List<ValidationMessage> ValidationMessages { get; } = [];

    public void AddRange(IEnumerable<ValidationMessage> updateSegmentLine)
    {
        ValidationMessages.AddRange(updateSegmentLine);
    }

    public override string ToString()
    {
        StringBuilder output = new();

        foreach (var message in ValidationMessages) output.AppendLine(message.ToString());

        return output.ToString();
    }
}

================
File: EdiSource.Domain/Validation/Data/IIndirectValidatable.cs
================
using EdiSource.Domain.Identifiers;

namespace EdiSource.Domain.Validation.Data;

/// <summary>
///     Denotes an IEdi item that can be validated
/// </summary>
public interface IIndirectValidatable
{
    /// <summary>
    ///     Validates an IEdi item
    /// </summary>
    /// <returns></returns>
    IEnumerable<ValidationMessage> Validate(IEdi element);
}

public interface IIndirectValidatable<in T> : IIndirectValidatable
    where T : IEdi
{
    /// <summary>
    ///     Validates an IEdi item
    /// </summary>
    /// <returns></returns>
    IEnumerable<ValidationMessage> Validate(T element);
}

================
File: EdiSource.Domain/Validation/Data/ISourceGeneratorValidatable.cs
================
namespace EdiSource.Domain.Validation.Data;

/// <summary>
///     Denotes an IEdi item that's validation functions
///     will be source generated
/// </summary>
public interface ISourceGeneratorValidatable
{
    /// <summary>
    ///     Validates an IEdi item
    /// </summary>
    /// <returns></returns>
    List<IIndirectValidatable> SourceGenValidations { get; }
}

================
File: EdiSource.Domain/Validation/Data/IValidatable.cs
================
using EdiSource.Domain.Identifiers;

namespace EdiSource.Domain.Validation.Data;

/// <summary>
///     Denotes an IEdi item that can be validated
/// </summary>
public interface IValidatable
{
    /// <summary>
    ///     Validates an IEdi item
    /// </summary>
    /// <returns></returns>
    IEnumerable<ValidationMessage> Validate();
}

/// <summary>
///     Denotes an IEdi item that can be validated
/// </summary>
public interface IUserValidation<T> : IEdi
{
    /// <summary>
    ///     Validates an IEdi item
    /// </summary>
    /// <returns></returns>
    public static List<Func<T, IEnumerable<ValidationMessage>>> UserValidations { get; } = [];
}

================
File: EdiSource.Domain/Validation/Data/ValidationMessage.cs
================
using System.Text;

namespace EdiSource.Domain.Validation.Data;

public sealed class ValidationMessage
{
    /// <summary>
    ///     The severity of the validation message
    /// </summary>
    public required ValidationSeverity Severity { get; set; }

    /// <summary>
    ///     The message, either containing information or an error
    /// </summary>
    public required string Message { get; set; }

    /// <summary>
    ///     The entity that produced the validation. Typically: "Segment", or "Loop".
    /// </summary>
    public ValidationSubject Subject { get; set; } = ValidationSubject.Unknown;

    /// <summary>
    ///     The loop line of the element in question
    /// </summary>
    public int? LoopLine { get; set; }

    /// <summary>
    ///     The segment line of the segment in question
    /// </summary>
    public int? SegmentLine { get; set; }

    /// <summary>
    ///     The name of the loop context
    /// </summary>
    public string? Loop { get; set; }

    /// <summary>
    ///     The segment data in question
    /// </summary>
    public string? Segment { get; set; }

    /// <summary>
    ///     The data element position in question
    /// </summary>
    public int? DataElement { get; set; }

    /// <summary>
    ///     The composite element position in question
    /// </summary>
    public int? CompositeElement { get; set; }

    public string? Value { get; set; }

    public override string ToString()
    {
        var sb = new StringBuilder();
        sb.Append($"Severity: {Severity}");

        sb.Append($", Subject: {Subject}");

        if (Loop != null) sb.Append($", Loop: {Loop}");

        if (LoopLine.HasValue) sb.Append($", LoopLine: {LoopLine}");

        if (SegmentLine.HasValue) sb.Append($", SegmentLine: {SegmentLine}");

        if (DataElement.HasValue) sb.Append($", DataElement: {DataElement}");

        if (CompositeElement.HasValue) sb.Append($", CompositeElement: {CompositeElement}");

        if (Value is not null) sb.Append($", Value: {Value}");

        sb.Append($" Message: {Message}");

        if (Segment != null) sb.Append($", Segment: {Segment}");

        return sb.ToString();
    }
}

================
File: EdiSource.Domain/Validation/Data/ValidationMessage.Extensions.cs
================
namespace EdiSource.Domain.Validation.Data;

internal static class ValidationMessageExtensions
{
    /// <summary>
    ///     Updates all validation message's SegmentLine to the input value
    /// </summary>
    /// <param name="messages"></param>
    /// <param name="line"></param>
    /// <returns></returns>
    public static IEnumerable<ValidationMessage> UpdateSegmentLine(this IEnumerable<ValidationMessage> messages,
        int line)
    {
        var updateSegmentLine = messages as ValidationMessage[] ?? messages.ToArray();
        foreach (var message in updateSegmentLine) message.SegmentLine = line;

        return updateSegmentLine;
    }

    /// <summary>
    ///     Updates all validation message's LoopLine to the input value
    /// </summary>
    /// <param name="messages"></param>
    /// <param name="line"></param>
    /// <returns></returns>
    public static IEnumerable<ValidationMessage> UpdateLoopLine(this IEnumerable<ValidationMessage> messages,
        int line)
    {
        var updateSegmentLine = messages as ValidationMessage[] ?? messages.ToArray();
        foreach (var message in updateSegmentLine) message.LoopLine = line;

        return updateSegmentLine;
    }
}

================
File: EdiSource.Domain/Validation/Data/ValidationMessageTablePrinter.cs
================
namespace EdiSource.Domain.Validation.Data;

public static class ValidationMessageTablePrinter
{
    private const int SeverityWidth = 10;
    private const int SubjectWidth = 20;
    private const int LoopWidth = 15;
    private const int SegmentWidth = 70;
    private const int DataElementWidth = 15;
    private const int ValueWidth = 20;
    private const int MessageWidth = 60;

    private static string _separator = string.Empty;

    public static void PrintColorCodedValidationMessagesTable(EdiValidationResult validationResult,
        params ValidationSeverity[] severities)
    {
        var messages = validationResult
            .ValidationMessages
            .Where(x => severities.Contains(x.Severity));

        PrintColorCodedValidationMessagesTable([..messages]);
    }

    public static void PrintColorCodedValidationMessagesTable(IEnumerable<ValidationMessage> messages)
    {
        PrintColorCodedValidationMessagesTable([..messages]);
    }

    public static void PrintColorCodedValidationMessagesTable(ValidationMessage[] messages)
    {
        if (messages.Length == 0)
        {
            Console.WriteLine("No validation messages to display.");
            return;
        }

        PrintHeader();

        foreach (var message in messages) PrintRow(message);

        PrintSeparator();
    }

    private static void PrintHeader(params int[] columnWidths)
    {
        PrintSeparator();
        Console.ForegroundColor = ConsoleColor.Cyan;

        var headerText = $"| {"Severity".Adjust(SeverityWidth)} " +
                         $"| {"Subject".Adjust(SubjectWidth)} " +
                         $"| {"Loop".Adjust(LoopWidth)} " +
                         $"| {"Data Element".Adjust(DataElementWidth)} " +
                         $"| {"Value".Adjust(ValueWidth)} " +
                         $"| {"Message".Adjust(MessageWidth)} " +
                         $"| {"Segment".Adjust(SegmentWidth)} |";

        if (_separator.Length == 0) _separator = new string('-', headerText.Length);

        Console.WriteLine(headerText);
        Console.ResetColor();
        PrintSeparator();
    }

    private static void PrintRow(ValidationMessage message, params int[] columnWidths)
    {
        SetSeverityColor(message.Severity);
        Console.Write($"| {message.Severity.ToString().Adjust(SeverityWidth)} ");
        Console.ResetColor();
        Console.WriteLine(
            $"| {message.Subject.ToString().Adjust(SubjectWidth)} " +
            $"| {(message.Loop ?? "").Adjust(LoopWidth)} " +
            $"| {(message.DataElement.HasValue ? message.DataElement.Value.ToString() : "").Adjust(DataElementWidth)} " +
            $"| {(message.Value ?? "").Adjust(ValueWidth)} " +
            $"| {message.Message.Adjust(MessageWidth)} " +
            $"| {(message.Segment ?? "").Adjust(SegmentWidth)} |"
        );
    }

    private static string Adjust(this string value, int width)
    {
        var needsTrimming = value.Length > width;

        if (!needsTrimming) return value.PadRight(width, ' ');

        return value[..(width - 3)] + "...";
    }

    private static void PrintSeparator()
    {
        Console.WriteLine(_separator);
    }

    private static void SetSeverityColor(ValidationSeverity severity)
    {
        Console.ForegroundColor = severity switch
        {
            ValidationSeverity.Critical => ConsoleColor.Magenta,
            ValidationSeverity.Error => ConsoleColor.Red,
            ValidationSeverity.Warning => ConsoleColor.Yellow,
            ValidationSeverity.Info => ConsoleColor.Green,
            _ => ConsoleColor.Gray
        };
    }
}

================
File: EdiSource.Domain/Validation/Data/ValidationSeverity.cs
================
namespace EdiSource.Domain.Validation.Data;

/// <summary>
///     Validation severities in escalating order
/// </summary>
public enum ValidationSeverity
{
    None = 0,
    Info = 1,
    Warning = 2,
    Error = 3,
    Critical = 4
}

================
File: EdiSource.Domain/Validation/Data/ValidationSubject.cs
================
namespace EdiSource.Domain.Validation.Data;

/// <summary>
///     The subject of validation
/// </summary>
[Flags]
public enum ValidationSubject
{
    Unknown = 0,
    Segment = 1,
    Loop = 2
}

public static class ValidationSubjectExtensions
{
    public static string ToEnumString(this ValidationSubject subject)
    {
        return subject switch
        {
            ValidationSubject.Unknown => "Unknown",
            ValidationSubject.Segment => "Segment",
            ValidationSubject.Loop => "Loop",
            _ => "Unknown"
        };
    }

    public static ValidationSubject FromString(string value)
    {
        return value switch
        {
            "Unknown" => ValidationSubject.Unknown,
            "Segment" => ValidationSubject.Segment,
            "Loop" => ValidationSubject.Loop,
            _ => ValidationSubject.Unknown
        };
    }
}

================
File: EdiSource.Domain/Validation/Factory/ValidationFactory.Loop.cs
================
using EdiSource.Domain.Loop;
using EdiSource.Domain.Validation.Data;

namespace EdiSource.Domain.Validation.Factory;

public static partial class ValidationFactory
{
    public static ValidationMessage Create(ILoop loop, ValidationSeverity validationSeverity,
        string message)
    {
        return new ValidationMessage
        {
            Severity = validationSeverity,
            Subject = ValidationSubject.Loop,
            Message = message,
            Loop = loop.GetType().Name
        };
    }

    public static ValidationMessage CreateCritical(ILoop loop,
        string message)
    {
        return Create(loop, ValidationSeverity.Critical, message);
    }

    public static ValidationMessage CreateError(ILoop loop,
        string message)
    {
        return Create(loop, ValidationSeverity.Error, message);
    }

    public static ValidationMessage CreateWarning(ILoop loop,
        string message)
    {
        return Create(loop, ValidationSeverity.Warning, message);
    }

    public static ValidationMessage CreateInfo(ILoop loop,
        string message)
    {
        return Create(loop, ValidationSeverity.Info, message);
    }
}

================
File: EdiSource.Domain/Validation/Factory/ValidationFactory.Segment.cs
================
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;

namespace EdiSource.Domain.Validation.Factory;

public static partial class ValidationFactory
{
    public static ValidationMessage Create(Segment segment, ValidationSeverity validationSeverity,
        string message, int? dataElement = null, int? compositeElement = null)
    {
        return new ValidationMessage
        {
            Severity = validationSeverity,
            Subject = ValidationSubject.Segment,
            Message = message,
            Loop = null, // segment.Parent ? parent.Parent?.GetType().Name : null,
            Segment = segment.ToString(),
            DataElement = dataElement,
            CompositeElement = compositeElement,
            Value = dataElement is { } de && compositeElement is { } ce
                ? segment.GetCompositeElementOrNull(de, ce)
                : null
        };
    }

    public static ValidationMessage CreateCritical(Segment segment,
        string message, int? dataElement = null, int? compositeElement = null)
    {
        return Create(segment, ValidationSeverity.Error, message, dataElement, compositeElement);
    }

    public static ValidationMessage CreateError(Segment segment,
        string message, int? dataElement = null, int? compositeElement = null)
    {
        return Create(segment, ValidationSeverity.Error, message, dataElement, compositeElement);
    }

    public static ValidationMessage CreateWarning(Segment segment,
        string message, int? dataElement = null, int? compositeElement = null)
    {
        return Create(segment, ValidationSeverity.Warning, message, dataElement, compositeElement);
    }

    public static ValidationMessage CreateInfo(Segment segment,
        string message, int? dataElement = null, int? compositeElement = null)
    {
        return Create(segment, ValidationSeverity.Info, message, dataElement, compositeElement);
    }
}

================
File: EdiSource.Domain/Validation/IO/IValidationMessageCsvConverter.cs
================
using EdiSource.Domain.Validation.Data;

namespace EdiSource.Domain.Validation.IO;

/// <summary>
///     Converts validation messages to a comma seperated value
/// </summary>
public interface IValidationMessageCsvConverter
{
    Task WriteToCsvAsync(EdiValidationResult result, FileInfo fileInfo,
        CancellationToken cancellationToken = default);

    string ToCsvString(EdiValidationResult result);
}

================
File: EdiSource.Domain/Validation/IO/ValidationMessageCsvConverter.cs
================
using System.Text;
using EdiSource.Domain.Validation.Data;

namespace EdiSource.Domain.Validation.IO;

public sealed class ValidationMessageCsvConverter : IValidationMessageCsvConverter
{
    public async Task WriteToCsvAsync(EdiValidationResult result, FileInfo fileInfo,
        CancellationToken cancellationToken = default)
    {
        await File.WriteAllTextAsync(fileInfo.FullName, ToCsvString(result), cancellationToken);
    }

    public string ToCsvString(EdiValidationResult result)
    {
        var csvBuilder = new StringBuilder();

        csvBuilder.AppendLine(GetCsvHeader());

        foreach (var message in result.ValidationMessages) csvBuilder.AppendLine(ConvertToCsvRow(message));

        return csvBuilder.ToString();
    }

    private static string GetCsvHeader()
    {
        return string.Join(",", "ValidationSeverity", "Message", "Subject", "LoopLine", "SegmentLine", "Loop",
            "Segment", "DataElement", "CompositeElement");
    }

    private static string ConvertToCsvRow(ValidationMessage message)
    {
        return string.Join(",", EscapeCsvField(message.Severity.ToString()), EscapeCsvField(message.Message),
            EscapeCsvField(message.Subject.ToEnumString()), EscapeCsvField(message.LoopLine?.ToString() ?? ""),
            EscapeCsvField(message.SegmentLine?.ToString() ?? ""), EscapeCsvField(message.Loop ?? ""),
            EscapeCsvField(message.Segment ?? ""), EscapeCsvField(message.DataElement?.ToString() ?? ""),
            EscapeCsvField(message.CompositeElement?.ToString() ?? ""));
    }

    private static string EscapeCsvField(string field)
    {
        if (string.IsNullOrEmpty(field))
            return "";

        var needsQuotes = field.Contains(',') || field.Contains('"') || field.Contains('\r') || field.Contains('\n');

        return needsQuotes ? $"\"{field.Replace("\"", "\"\"")}\"" : field;
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/BeDateAttribute.cs
================
using System.Globalization;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Standard.Date;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class BeDateAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement,
    string? format = null)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is not { } value)
            yield break;

        var formats = format is null
            ? DateFormats.StandardFormats
            : [format];

        foreach (var _ in formats
                     .Where(f => DateOnly.TryParseExact(value, format, null, DateTimeStyles.None, out _)))
            yield break;

        yield return ValidationFactory.Create(
            segment,
            validationSeverity,
            $"Data element {dataElement} in composite element {compositeElement} should be a date but is not",
            dataElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/BeDateTimeAttribute.cs
================
using System.Globalization;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Standard.Date;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public sealed class BeDateTimeAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement,
    string? format = null)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is not { } value)
            yield break;

        var formats = format is null
            ? DateFormats.StandardFormats
            : [format];

        foreach (var _ in formats
                     .Where(f => DateOnly.TryParseExact(value, format, null, DateTimeStyles.None, out _)))
            yield break;

        yield return ValidationFactory.Create(
            segment,
            validationSeverity,
            $"Data element {dataElement} in composite element {compositeElement} should be a date but is not",
            dataElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/BeDecimalAttribute.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class BeDecimalAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is { } value
            && !decimal.TryParse(value, out _))
            yield return ValidationFactory.Create(
                segment,
                validationSeverity,
                $"Data element {dataElement} in composite element {compositeElement} should be a decimal but is not",
                dataElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/BeIntAttribute.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class BeIntAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is { } value
            && !int.TryParse(value, out _))
            yield return ValidationFactory.Create(
                segment,
                validationSeverity,
                $"Data element {dataElement} in composite element {compositeElement} should be a time but is not",
                dataElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/BeTime.cs
================
using System.Globalization;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class BeTimeAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement,
    string format = "HHmm")
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is { } value
            && !TimeOnly.TryParseExact(value, format, null, DateTimeStyles.None, out _))
            yield return ValidationFactory.Create(
                segment,
                validationSeverity,
                $"Data element {dataElement} in composite element {compositeElement} is required but does not exist",
                dataElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/CompositeElementLengthAttribute.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class CompositeElementLengthAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement,
    int min,
    int max)
    : Attribute, IIndirectValidatable
{
    public CompositeElementLengthAttribute(ValidationSeverity validationSeverity, int dataElement, int compositeElement,
        int length)
        : this(validationSeverity, dataElement, compositeElement, length, length)
    {
    }

    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        return segment.GetCompositeElementOrNull(dataElement, compositeElement) is { } value &&
               value.Length < min &&
               value.Length > max
            ? [CreateValidationMessage(segment, value.Length)]
            : [];
    }

    private ValidationMessage CreateValidationMessage(Segment segment, int value)
    {
        return ValidationFactory.Create(
            segment,
            validationSeverity,
            $"Element {dataElement} in composite {compositeElement} has length {value} which is not between {min} and {max}",
            dataElement,
            compositeElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/ElementLengthAttribute.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public sealed class ElementLengthAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int min,
    int max)
    : Attribute, IIndirectValidatable
{
    public ElementLengthAttribute(ValidationSeverity validationSeverity, int dataElement, int length)
        : this(validationSeverity, dataElement, length, length)
    {
    }

    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        return segment.GetElementOrNull(dataElement) is { } ce &&
               ce.Sum(x => x.Length) is var sumLength &&
               sumLength < min &&
               sumLength > max
            ? [CreateValidationMessage(segment, sumLength)]
            : [];
    }

    private ValidationMessage CreateValidationMessage(Segment segment, int value)
    {
        return ValidationFactory.Create(
            segment,
            validationSeverity,
            $"Element {dataElement}  has length {value} which is not between {min} and {max}",
            dataElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/EmptyAttribute.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class EmptyAttribute(ValidationSeverity validationSeverity, int dataElement, int compositeElement)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is { } value
            && value.Length != 0)
            yield return ValidationFactory.Create(
                segment,
                validationSeverity,
                $"Element {dataElement} in composite {compositeElement} has should be empty",
                dataElement,
                compositeElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/IsOneOfValuesAttribute.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class IsOneOfValuesAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement,
    params string[] values)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is { } value
            && !values.Contains(value))
            yield return ValidationFactory.Create(
                segment,
                validationSeverity,
                $"Element {dataElement} in composite {compositeElement} must be one of: {string.Join(", ", values)}",
                dataElement,
                compositeElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/NotEmptyAttribute.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class NotEmptyAttribute(ValidationSeverity validationSeverity, int dataElement, int compositeElement)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is { Length: 0 })
            yield return ValidationFactory.Create(
                segment,
                validationSeverity,
                $"Element {dataElement} in composite {compositeElement} has should not be empty",
                dataElement,
                compositeElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/NotOneOfValuesAttribute.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class NotOneOfValuesAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement,
    params string[] values)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is { } value
            && value.Contains(value))
            yield return ValidationFactory.Create(
                segment,
                validationSeverity,
                $"Element {dataElement} in composite {compositeElement} must not be one of: {string.Join(", ", values)}",
                dataElement,
                compositeElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/RequiredDataElements.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class RequiredDataElementsAttribute(ValidationSeverity validationSeverity, int[] dataElements)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        foreach (var dataElement in dataElements)
            if (segment.GetCompositeElementOrNull(dataElement) is null)
                yield return ValidationFactory.Create(
                    segment,
                    validationSeverity,
                    $"Data element {dataElement} is required but does not exist",
                    dataElement);
    }
}

================
File: EdiSource.Domain/Validation/SourceGeneration/RequiredElement.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.Factory;

namespace EdiSource.Domain.Validation.SourceGeneration;

[AttributeUsage(AttributeTargets.Class)]
public sealed class RequiredElementAttribute(
    ValidationSeverity validationSeverity,
    int dataElement,
    int compositeElement)
    : Attribute, IIndirectValidatable
{
    public IEnumerable<ValidationMessage> Validate(IEdi element)
    {
        if (element is not Segment segment)
            throw new ArgumentException("Element must be a segment", nameof(element));

        if (segment.GetCompositeElementOrNull(dataElement, compositeElement) is null)
            yield return ValidationFactory.Create(
                segment,
                validationSeverity,
                $"Data element {dataElement} in composite element {compositeElement} is required but does not exist",
                dataElement);
    }
}

================
File: EdiSource.Domain/Validation/Validator/IValidateEdi.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Validation.Data;

namespace EdiSource.Domain.Validation.Validator;

/// <summary>
///     Validates an IEdi item
/// </summary>
public interface IValidateEdi
{
    /// <summary>
    ///     Enacts validation on an IEdi item
    /// </summary>
    /// <param name="ediItem"></param>
    /// <param name="additionalValidations"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    EdiValidationResult Validate<T>(T ediItem)
        where T : IEdi;
}

================
File: EdiSource.Domain/Validation/Validator/ValidateEdi.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Validation.Data;

namespace EdiSource.Domain.Validation.Validator;

public sealed class ValidateEdi : IValidateEdi
{
    /// <summary>
    ///     Validates an IEdi item
    /// </summary>
    /// <param name="ediItem"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public EdiValidationResult Validate<T>(T ediItem) where T : IEdi
    {
        var loopLine = 0;
        var segmentLine = 0;
        return YieldValidationMessages(ediItem, null, ref loopLine, ref segmentLine);
    }

    private static EdiValidationResult YieldValidationMessages<T>(T ediItem, EdiValidationResult? validationResult,
        ref int loopLine, ref int segmentLine) where T : IEdi
    {
        validationResult ??= new EdiValidationResult();

        switch (ediItem)
        {
            case null: return validationResult;
            case Segment segment:
                HandleSegment<T>(validationResult, loopLine, ref segmentLine, segment);
                break;
            case IEnumerable<Segment> segmentList:
                HandleSegmentList<T>(validationResult, loopLine, ref segmentLine, segmentList);
                break;
            case ILoop loop:
                HandleLoop<T>(validationResult, out loopLine, ref segmentLine, loop);
                break;
            case IEnumerable<ILoop> loopList:
                HanldeLoopList<T>(validationResult, out loopLine, ref segmentLine, loopList);
                break;
        }

        return validationResult;
    }

    private static void HanldeLoopList<T>(EdiValidationResult validationResult, out int loopLine, ref int segmentLine,
        IEnumerable<ILoop> loopList) where T : IEdi
    {
        loopLine = segmentLine;

        foreach (var loop in loopList) HandleLoop<T>(validationResult, out loopLine, ref segmentLine, loop);
    }

    private static void HandleLoop<T>(EdiValidationResult validationResult, out int loopLine, ref int segmentLine,
        ILoop loop) where T : IEdi
    {
        loopLine = segmentLine;

        if (loop is T edi)
            foreach (var userValidation in IUserValidation<T>.UserValidations)
                validationResult.AddRange(userValidation(edi)
                    .UpdateLoopLine(loopLine));

        if (loop is IValidatable v)
            validationResult.AddRange(v
                .Validate()
                .UpdateLoopLine(loopLine));

        if (loop is ISourceGeneratorValidatable v2)
            foreach (var sourceValidation in v2.SourceGenValidations)
                validationResult.AddRange(sourceValidation
                    .Validate(loop)
                    .UpdateLoopLine(loopLine));

        foreach (var item in loop.EdiItems.OfType<IEdi>())
            YieldValidationMessages(item, validationResult, ref loopLine, ref segmentLine);
    }

    private static void HandleSegmentList<T>(EdiValidationResult validationResult, int loopLine, ref int segmentLine,
        IEnumerable<Segment> segmentList) where T : IEdi
    {
        foreach (var segment in segmentList) HandleSegment<T>(validationResult, loopLine, ref segmentLine, segment);
    }

    private static void HandleSegment<T>(EdiValidationResult validationResult, int loopLine, ref int segmentLine,
        Segment segment) where T : IEdi
    {
        if (segment is IValidatable v)
            validationResult.AddRange(v
                .Validate()
                .UpdateSegmentLine(segmentLine)
                .UpdateLoopLine(loopLine));

        if (segment is ISourceGeneratorValidatable v2)
            foreach (var sourceValidation in v2.SourceGenValidations)
                validationResult.AddRange(sourceValidation
                    .Validate((IEdi)segment)
                    .UpdateSegmentLine(segmentLine)
                    .UpdateLoopLine(loopLine));

        if (segment is T t)
            foreach (var userValidation in IUserValidation<T>.UserValidations)
                validationResult.AddRange(userValidation(t)
                    .UpdateSegmentLine(segmentLine)
                    .UpdateLoopLine(loopLine));

        segmentLine++;
    }
}

================
File: EdiSource.Domain/Validation/Validator/ValidationHelper.cs
================
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Validation.Data;

namespace EdiSource.Domain.Validation.Validator;

public static class ValidationHelper
{
    public static void Add<T>(Func<T, IEnumerable<ValidationMessage>> it) where T : IEdi
    {
        IUserValidation<T>.UserValidations.Add(it);
        IUserValidation<IEdi>.UserValidations.Add(x => x is not T t ? [] : it(t));
    }

    public static void Add<T>(List<Func<T, IEnumerable<ValidationMessage>>> items) where T : IEdi
    {
        foreach (var it in items)
        {
            IUserValidation<T>.UserValidations.Add(it);
            IUserValidation<IEdi>.UserValidations.Add(x => x is not T t ? [] : it(t));
        }
    }

    public static Func<TR, IEnumerable<ValidationMessage>> ConvertIt<T, TR>(
        this Func<T, IEnumerable<ValidationMessage>> func)
        where T : class
        where TR : class, T
    {
        return func;
    }

    public static List<Func<TR, IEnumerable<ValidationMessage>>> ConvertMultiple<T, TR>(
        this IEnumerable<Func<T, IEnumerable<ValidationMessage>>> func)
        where T : class
        where TR : class, T
    {
        List<Func<TR, IEnumerable<ValidationMessage>>> result = [];
        result.AddRange(func.Select(item => item.ConvertIt<T, TR>()));
        return result;
    }

    public static Func<TR, IEnumerable<ValidationMessage>> ConvertValidatable<T, TR>(
        this T it)
        where T : class, IValidatable
        where TR : class, T
    {
        return _ => it.Validate();
    }
}

================
File: EdiSource.Domain/EdiCommon.cs
================
using System.Text;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.IO.EdiReader;
using EdiSource.Domain.IO.Parser;
using EdiSource.Domain.IO.Serializer;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Separator;
using EdiSource.Domain.Standard.Loops.ISA;
using EdiSource.Domain.Validation.Data;
using EdiSource.Domain.Validation.IO;
using EdiSource.Domain.Validation.Validator;

namespace EdiSource.Domain;

/// <summary>
///     Common functionality for most use cases
/// </summary>
public static class EdiCommon
{
    /// <summary>
    ///     Parses an EDI envelope from a StreamReader.
    /// </summary>
    /// <typeparam name="T">The type of the object that implements ILoopInitialize.</typeparam>
    /// <param name="stream">The StreamReader to read the EDI envelope from.</param>
    /// <param name="separators">The edi separators, or the default ones from Separators.DefaultSeparators if not provided</param>
    /// <param name="cancellationToken">Optional. A CancellationToken to observe while waiting for the task to complete.</param>
    /// <returns>A task that represents the asynchronous parse operation. The task result contains the parsed object.</returns>
    public static Task<T> ParseEdi<T>(StreamReader stream, Separators? separators = null,
        CancellationToken cancellationToken = default)
        where T : class, ILoopInitialize<T>, new()
    {
        return new EdiParser<T>().ParseEdi(stream, separators, cancellationToken);
    }

    /// <summary>
    ///     Parses an EDI envelope from the given FileInfo with an optional cancellation token.
    /// </summary>
    /// <typeparam name="T">
    ///     The type of the data structure to parse the EDI envelope into. Must implement ILoopInitialize&lt;T
    ///     &gt; and have a parameterless constructor.
    /// </typeparam>
    /// <param name="fileInfo">The FileInfo from which to read the EDI data.</param>
    /// <param name="separators">The edi separators, or the default ones from Separators.DefaultSeparators if not provided</param>
    /// <param name="cancellationToken">An optional CancellationToken to observe while waiting for the task to complete.</param>
    /// <returns>A task representing the asynchronous parse operation, with the parsed EDI data structure as its result.</returns>
    public static Task<T> ParseEdi<T>(FileInfo fileInfo, Separators? separators = null,
        CancellationToken cancellationToken = default)
        where T : class, ILoopInitialize<T>, new()
    {
        return new EdiParser<T>().ParseEdi(fileInfo, separators, cancellationToken);
    }

    public static async Task<List<Segment>> ParseIntoSegments(string text, Separators? separators = null,
        CancellationToken cancellationToken = default)
    {
        using var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(text));
        using var streamReader = new StreamReader(memoryStream);
        return await new EdiReader().ReadEdSegmentsAsync(streamReader, separators, cancellationToken);
    }

    /// <summary>
    ///     Parses an EDI envelope from a stream and returns an object of type T,
    ///     which must be a class implementing ILoopInitialize.
    /// </summary>
    /// <typeparam name="T">The type of object to return, which must implement ILoopInitialize.</typeparam>
    /// <param name="text">The text to read the EDI envelope data from.</param>
    /// <param name="separators">The edi separators, or the default ones from Separators.DefaultSeparators if not provided</param>
    /// <returns>A task representing the asynchronous operation, with a result of type T.</returns>
    public static Task<T> ParseEdi<T>(string text, Separators? separators = null)
        where T : class, ILoopInitialize<T>, new()
    {
        return new EdiParser<T>().ParseEdi(text, separators);
    }

    /// <summary>
    ///     Writes an EDI representation of the given loop to the specified stream.
    /// </summary>
    /// <typeparam name="T">The type of the EDI loop.</typeparam>
    /// <param name="loop">The EDI loop to be written.</param>
    /// <param name="stream">The stream to which the EDI data will be written.</param>
    /// <param name="separators">
    ///     Optional separators to use for delimiting the EDI data. If null, default separators will be
    ///     used.
    /// </param>
    /// <param name="includeNewLine">Indicates whether to include new lines in the EDI output.</param>
    /// <param name="cancellationToken">Optional cancellation token to cancel the operation.</param>
    /// <returns>A task representing the asynchronous write operation.</returns>
    public static Task WriteEdi<T>(T loop, Stream stream, Separators? separators = null, bool includeNewLine = true,
        CancellationToken cancellationToken = default)
        where T : class, ILoop
    {
        return new EdiSerializer().WriteToStream(loop, stream, separators, includeNewLine, cancellationToken);
    }

    /// <summary>
    ///     Writes EDI data to a specified file.
    /// </summary>
    /// <param name="loop">The loop containing the EDI data to write.</param>
    /// <param name="fileInfo">The file information specifying the file to write to.</param>
    /// <param name="separators">Optional. The separators to use in the EDI data.</param>
    /// <param name="includeNewLine">Indicates whether to include new lines in the EDI output.</param>
    /// <param name="cancellationToken">Optional. The cancellation token to cancel the operation.</param>
    /// <typeparam name="T">The type of the loop.</typeparam>
    /// <returns>A task representing the asynchronous write operation.</returns>
    public static Task WriteEdi<T>(T loop, FileInfo fileInfo, Separators? separators = null, bool includeNewLine = true,
        CancellationToken cancellationToken = default)
        where T : class, ILoop
    {
        return new EdiSerializer().WriteToFile(loop, fileInfo, separators, includeNewLine, cancellationToken);
    }

    /// <summary>
    ///     Converts the provided loop structure to an EDI string format.
    /// </summary>
    /// <param name="loop">The loop structure to convert to an EDI string.</param>
    /// <param name="separators">
    ///     The optional separators to use for the EDI string. If not provided, default separators will be
    ///     used.
    /// </param>
    /// <param name="includeNewLine">Specifies whether to include newline characters in the output EDI string.</param>
    /// <returns>A string representing the loop structure in EDI format.</returns>
    public static string WriteEdiToString<T>(T loop, Separators? separators = null, bool includeNewLine = true)
        where T : class, ILoop
    {
        separators ??= Separators.DefaultSeparators;
        return new EdiSerializer().WriteToString(loop, separators, includeNewLine);
    }

    /// <summary>
    ///     Validates the provided EDI item and returns the validation results.
    /// </summary>
    /// <typeparam name="T">The type of the EDI item to be validated, which must implement the IEdi interface.</typeparam>
    /// <param name="it">The instance of the EDI item to be validated.</param>
    /// <returns>An EdiValidationResult instance containing the results of the validation.</returns>
    public static EdiValidationResult Validate<T>(T it)
        where T : IEdi
    {
        var validator = new ValidateEdi();
        return validator.Validate(it);
    }

    /// <summary>
    ///     Writes the validation messages to a CSV file.
    /// </summary>
    /// <param name="validationResult">The EDI validation result containing validation messages.</param>
    /// <param name="fileInfo">The FileInfo object representing the file to which the CSV will be written.</param>
    /// <param name="cancellationToken">A token to monitor for cancellation requests.</param>
    /// <returns>A Task representing the asynchronous operation.</returns>
    public static Task WriteValidationsToCsvFile(EdiValidationResult validationResult, FileInfo fileInfo,
        CancellationToken cancellationToken = default)
    {
        var writer = new ValidationMessageCsvConverter();
        return writer.WriteToCsvAsync(validationResult, fileInfo, cancellationToken);
    }

    /// <summary>
    ///     Generates a human-readable representation of the EDI structure.
    /// </summary>
    /// <typeparam name="T">The type of the EDI loop implementing ILoop.</typeparam>
    /// <param name="it">The instance of the EDI loop to be pretty printed.</param>
    /// <returns>A string that contains the pretty-printed representation of the EDI structure.</returns>
    public static string PrettyPrint<T>(T it)
        where T : ILoop
    {
        return new EdiSerializer().WriteToPrettyString(it);
    }
}

================
File: EdiSource.Domain/EdiSource.Domain.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <WarningsAsErrors>true</WarningsAsErrors>
    </PropertyGroup>

</Project>

================
File: EdiSource.Domain/GlobalUsings.cs
================
global using static EdiSource.Domain.Helper.GeneralExtensions;

================
File: EdiSource.Domain.Tests/Segments/SegmentTests.cs
================
namespace EdiSource.Domain.Tests.Segments;

public class SegmentTests
{
}

================
File: EdiSource.Domain.Tests/EdiSource.Domain.Tests.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>

        <IsPackable>false</IsPackable>
        <IsTestProject>true</IsTestProject>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="coverlet.collector" Version="6.0.2"/>
        <PackageReference Include="FluentAssertions" Version="6.12.1"/>
        <PackageReference Include="JetBrains.Annotations" Version="2024.3.0-eap1"/>
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp.SourceGenerators.Testing.XUnit" Version="1.1.2"/>
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.1"/>
        <PackageReference Include="NSubstitute" Version="5.1.0"/>
        <PackageReference Include="xunit" Version="2.9.2"/>
        <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
        <Using Include="Xunit"/>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\EdiSource.Domain\EdiSource.Domain.csproj"/>
    </ItemGroup>

</Project>

================
File: EdiSource.Domain.Tests/UnitTest1.cs
================
namespace EdiSource.Domain.Tests;

public class UnitTest1
{
    [Fact]
    public void Test1()
    {
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/Helper/CodeWriter.cs
================
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace EdiSource.Generator.Helper;

public sealed class CodeWriter
{
    private const string Indent =
        "                                                                                                                                ";

    private readonly StringBuilder _builder = new();
    private readonly Stack<string> _disposeStack = new(0);
    private int _indentLevel;

    public CodeWriter()
    {
        AppendLine("// <auto-generated/>");
        AppendLine("#nullable enable");
    }

    public void Append(string span)
    {
        _builder.Append(span);
    }

    public void AppendLine(string line = "")
    {
        if (!string.IsNullOrEmpty(line))
        {
            _builder.Append(Indent.Substring(0, _indentLevel * 4));
            _builder.AppendLine(line);
        }
        else
        {
            _builder.AppendLine();
        }
    }


    public IDisposable AppendLineIndent(string line = "")
    {
        if (!string.IsNullOrEmpty(line))
        {
            _builder.Append(Indent.Substring(0, _indentLevel * 4));
            _builder.AppendLine(line);
        }
        else
        {
            _builder.AppendLine();
        }

        return new IndentationBlock(this);
    }

    public IDisposable AppendBlock(string line = "", string blockChar = "{", string blockEndChar = "}")
    {
        AppendLine(line);

        AppendLine(blockChar);

        return new IndentationBlock(this, blockEndChar);
    }

    public void IncreaseIndent()
    {
        _indentLevel++;
    }

    public void DecreaseIndent()
    {
        _indentLevel--;
    }

    public IDisposable IndentBlock()
    {
        return new IndentationBlock(this);
    }

    public IDisposable StartNamespace(string namespaceName)
    {
        AppendLine($"namespace {namespaceName}");
        AppendLine("{");
        return new IndentationBlock(this);
    }

    public void AddUsing(string usingName)
    {
        AppendLine($"using {usingName};");
    }

    public IDisposable StartClass(string className, ReadOnlySpan<string> implementations, string modifier = "public",
        bool partial = true)
    {
        if (implementations.Length == 0)
        {
            AppendLine(partial
                ? $"{modifier} partial class {className}"
                : $"{modifier} class {className}");
            AppendLine("{");
            return new IndentationBlock(this);
        }

        AppendLine(partial
            ? $"{modifier} partial class {className}"
            : $"{modifier} class {className}");
        AppendLine($": {string.Join(", ", [..implementations])}");
        AppendLine("{");
        return new IndentationBlock(this);
    }

    public IDisposable StartMethod(string methodName, string returnType = "void", string modifier = "public",
        string[]? arguments = null)
    {
        AppendLine($"{modifier} {returnType} {methodName}({string.Join(", ", arguments ?? [])})");
        AppendLine("{");
        return new IndentationBlock(this);
    }

    public IDisposable StartConstructor(string className, string modifier = "public", params string[] arguments)
    {
        AppendLine($"{modifier} {className}({string.Join(", ", arguments)})");
        AppendLine("{");
        return new IndentationBlock(this);
    }

    public void AddAutoProperty(string propertyName, string propertyType, string modifier = "public",
        string? value = null)
    {
        if (value is not null)
            AppendLine($"{modifier} {propertyType} {propertyName} {{ get; set; }}");

        AppendLine($"{modifier} {propertyType} {propertyName} {{ get; set; }} = {value};");
    }

    public void AddCalcProperty(string propertyName, string propertyType, string calc, string modifier = "public")
    {
        AppendLine($"{modifier} {propertyType} {propertyName} => {calc};");
    }

    public IDisposable AddWhile(string condition)
    {
        AppendLine($"while ({condition})");
        AppendLine("{");
        return new IndentationBlock(this);
    }

    public IDisposable AddIf(string condition)
    {
        AppendLine($"if ({condition})");
        AppendLine("{");
        return new IndentationBlock(this);
    }

    public override string ToString()
    {
        // return _builder.ToString();
        return CSharpSyntaxTree
            .ParseText(_builder.ToString())
            .GetRoot()
            .NormalizeWhitespace()
            .ToFullString();
    }

    private class IndentationBlock : IDisposable
    {
        private readonly CodeWriter _writer;

        public IndentationBlock(CodeWriter writer, string dispose = "}")
        {
            _writer = writer;
            _writer._indentLevel++;
            _writer._disposeStack.Push(dispose);
        }

        public void Dispose()
        {
            _writer._indentLevel--;
            _writer.AppendLine(_writer._disposeStack.Pop());
        }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/Helper/Constants.cs
================
using System.Collections.Immutable;

namespace EdiSource.Generator.Helper;

public static class Constants
{
    //Non-attribute
    public const string LoopGenerator = "LoopGenerator";
    public const string SegmentHeader = "SegmentHeader";
    public const string SegmentFooter = "SegmentFooter";
    public const string OptionalSegmentFooter = "OptionalSegmentFooter";
    public const string Segment = "Segment";
    public const string SegmentList = "SegmentList";
    public const string Loop = "Loop";
    public const string LoopList = "LoopList";
    public const string SegmentGenerator = "SegmentGenerator";

    //Attribute
    public const string LoopGeneratorAttribute = "LoopGeneratorAttribute";
    public const string SegmentHeaderAttribute = "SegmentHeaderAttribute";
    public const string SegmentFooterAttribute = "SegmentFooterAttribute";
    public const string OptionalSegmentFooterAttribute = "OptionalSegmentFooterAttribute";
    public const string SegmentAttribute = "SegmentAttribute";
    public const string SegmentListAttribute = "SegmentListAttribute";
    public const string LoopAttribute = "LoopAttribute";
    public const string LoopListAttribute = "LoopListAttribute";
    public const string SegmentGeneratorAttribute = "SegmentGeneratorAttribute";


    public static HashSet<string> Usings =>
    [
        "EdiSource.Domain.Separator",
        "EdiSource.Domain.Segments",
        "EdiSource.Domain.Identifiers",
        "EdiSource.Domain.SourceGeneration",
        "EdiSource.Domain.Loop",
        "EdiSource.Domain.Validation.SourceGeneration",
        "EdiSource.Domain.Validation.Data",
        "System.Linq",
        "System.Collections.Generic",
        "System"
    ];

    public static class LoopAggregation
    {
        public static readonly ImmutableArray<string> LoopGeneratorNames = [LoopGenerator, LoopGeneratorAttribute];
        public static readonly ImmutableArray<string> SegmentHeaderNames = [SegmentHeader, SegmentHeaderAttribute];
        public static readonly ImmutableArray<string> SegmentFooterNames = [SegmentFooter, SegmentFooterAttribute];

        public static readonly ImmutableArray<string> OptionalSegmentFooterNames =
            [OptionalSegmentFooter, OptionalSegmentFooterAttribute];

        public static readonly ImmutableArray<string> SegmentNames = [Segment, SegmentAttribute];
        public static readonly ImmutableArray<string> SegmentListNames = [SegmentList, SegmentListAttribute];
        public static readonly ImmutableArray<string> LoopNames = [Loop, LoopAttribute];
        public static readonly ImmutableArray<string> LoopListNames = [LoopList, LoopListAttribute];

        public static readonly ImmutableArray<string> SegmentGeneratorNames =
            [SegmentGenerator, SegmentGeneratorAttribute];


        public static readonly ImmutableArray<string> Header = SegmentHeaderNames;

        public static readonly ImmutableArray<string> Body =
            [..SegmentNames, ..SegmentListNames, ..LoopNames, ..LoopListNames, ..OptionalSegmentFooterNames];

        public static readonly ImmutableArray<string> Footer = SegmentFooterNames;
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/Helper/HelperFunctions.cs
================
using System.Collections.Immutable;
using EdiSource.Generator.LoopGen.Data;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EdiSource.Generator.Helper;

public static class HelperFunctions
{
    public static bool IsEdiAttribute(string? attributeName)
    {
        return attributeName switch
        {
            SegmentHeaderAttribute or SegmentHeader => true,
            SegmentAttribute or Segment => true,
            SegmentListAttribute or SegmentList => true,
            LoopAttribute or Loop => true,
            LoopListAttribute or LoopList => true,
            SegmentFooterAttribute or SegmentFooter => true,
            OptionalSegmentFooterAttribute or OptionalSegmentFooter => true,
            _ => false
        };
    }

    public static ImmutableArray<(string Name, string Attribute, IPropertySymbol Property)> OrderEdiItems(
        IEnumerable<(string Name, string Attribute, IPropertySymbol Property)> ediItems)
    {
        return
        [
            ..ediItems.OrderBy(item => item.Attribute switch
            {
                SegmentHeaderAttribute or SegmentHeader => 0,
                SegmentAttribute or Segment => 1,
                SegmentListAttribute or SegmentList => 2,
                LoopAttribute or Loop => 3,
                LoopListAttribute or LoopList => 4,
                OptionalSegmentFooterAttribute or OptionalSegmentFooter => 5,
                SegmentFooterAttribute or SegmentFooter => 6,
                _ => 7
            })
        ];
    }

    public static string GetEdiAttribute(IPropertySymbol property)
    {
        var attributes = property.GetAttributes();
        var ediAttribute = attributes.FirstOrDefault(a => IsEdiAttribute(a.AttributeClass?.Name));
        return ediAttribute?.AttributeClass?.Name ?? string.Empty;
    }

    public static LoopMeta PredicateOnClassAttributes(GeneratorSyntaxContext context, ImmutableArray<string> items)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        var attribute = GetAttributeSyntax(classDeclarationSyntax, [..items])!;

        var typeArgumentListSyntaxes = attribute
            .DescendantNodes().OfType<TypeArgumentListSyntax>().ToList();

        var parent = typeArgumentListSyntaxes[0].Arguments[0].ToString();
        var self = typeArgumentListSyntaxes[0].Arguments[1].ToString();
        var id = typeArgumentListSyntaxes[0].Arguments[2].ToString();

        var isTransactionSet =
            attribute
                .DescendantNodes()
                .OfType<AttributeArgumentSyntax>()
                .FirstOrDefault()
                ?.Expression is { } expression
            && context.SemanticModel.GetConstantValue(expression) is var value
            && (bool)value.Value!;

        return new LoopMeta(
            classDeclarationSyntax,
            parent.RemoveQuestionMark(),
            self.RemoveQuestionMark(),
            id.RemoveQuestionMark(),
            isTransactionSet);
    }

    private static string RemoveQuestionMark(this string it)
    {
        return it.EndsWith("?") ? it[..^1] : it;
    }

    private static string? RemoveQuestionMarkNull(this string? it)
    {
        return it is null ? null : RemoveQuestionMark(it);
    }

    public static (ClassDeclarationSyntax, string loop, ImmutableArray<string> args, string? subType)
        PredicateOnClassAttributesClassParent(GeneratorSyntaxContext context, ImmutableArray<string> items)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        var attribute = GetAttributeSyntax(classDeclarationSyntax, [..items])!;

        var typeArgumentListSyntaxes = attribute
            .DescendantNodes().OfType<TypeArgumentListSyntax>().ToArray();

        var parent = typeArgumentListSyntaxes[0].Arguments[0].ToString();

        var subType =
            typeArgumentListSyntaxes[0].Arguments.Count == 2
                ? typeArgumentListSyntaxes[0].Arguments[1].ToString()
                : null;

        var args = attribute.DescendantNodes().OfType<AttributeArgumentSyntax>()
            .Select(x => x.Expression.ToString())
            .ToImmutableArray();

        return (classDeclarationSyntax, parent, args, subType);
    }

    public static TypeSyntax? GetSegmentGeneratorSubType(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        var attribute = GetAttributeSyntax(classDeclarationSyntax, [.. LoopAggregation.SegmentGeneratorNames]);

        if (attribute is null) return null;

        var typeArgumentListSyntaxes = attribute
            .DescendantNodes().OfType<TypeArgumentListSyntax>().ToArray();

        if (typeArgumentListSyntaxes.Length == 0)
            return null;

        return
            typeArgumentListSyntaxes[0].Arguments.Count == 2
                ? typeArgumentListSyntaxes[0].Arguments[1]
                : null;
    }

    public static bool IsSyntaxTargetForGeneration(SyntaxNode node, ImmutableArray<string> items)
    {
        return node is ClassDeclarationSyntax classDeclarationSyntax
               && HasAttribute(classDeclarationSyntax, [.. items]);
    }

    public static AttributeSyntax? GetAttributeSyntax(ClassDeclarationSyntax classDeclaration, string[] attributeNames)
    {
        foreach (var attributeList in classDeclaration.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var attributeName = attribute.Name.ToString();
            foreach (var name in attributeNames)
                if (attributeName.StartsWith($"{name}<"))
                    return attribute;
        }

        return null;
    }

    public static bool HasAttribute(ClassDeclarationSyntax classDeclaration, string[] attributeNames)
    {
        foreach (var attributeList in classDeclaration.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var attributeName = attribute.Name.ToString();
            foreach (var name in attributeNames)
                if (attributeName.StartsWith($"{name}<"))
                    return true;
        }

        return false;
    }

    public static IEnumerable<UsingDirectiveSyntax> GetUsingStatements(ClassDeclarationSyntax classDeclaration)
    {
        var parent = classDeclaration.Parent;

        while (parent != null && parent is not NamespaceDeclarationSyntax && !(parent is CompilationUnitSyntax))
            parent = parent.Parent;

        return parent switch
        {
            NamespaceDeclarationSyntax namespaceDeclaration => namespaceDeclaration.Usings,
            CompilationUnitSyntax compilationUnit => compilationUnit.Usings,
            _ => []
        };
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/Data/Attributes.cs
================
namespace EdiSource.Generator.LoopGen.Data;

internal static class LoopSourceGenAttributes
{
    public const string LoopAttribute =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        namespace EdiSource.Domain.SourceGeneration;

        /// <summary>
        ///     With a loop with the LoopGenerator attribute,
        ///     mark a loop with this attribute to enable source generation
        /// </summary>
        [AttributeUsage(AttributeTargets.Property)]
        public sealed class LoopAttribute : Attribute;
        """;

    public const string LoopGeneratorAttribute =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        using EdiSource.Domain.Identifiers;
        using EdiSource.Domain.Loop;
        using EdiSource.Domain.Segments;

        namespace EdiSource.Domain.SourceGeneration;

        /// <summary>
        ///     Enables source generation to occur on a loop.
        ///     Generics are needed for the source generation.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class)]
        public sealed class LoopGeneratorAttribute<TParent, TSelf, TId>(bool isTransactionSet = false) : Attribute
        #pragma warning restore CS9113 // Parameter is unread.
            where TParent : ILoop
            where TSelf : ILoop
            where TId : Segment, IEdi<TSelf>, ISegmentIdentifier<TId>;
        """;

    public const string LoopListAttribute =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        namespace EdiSource.Domain.SourceGeneration;

        /// <summary>
        ///     With a loop with the LoopGenerator attribute,
        ///     mark a loop list with this attribute to enable source generation
        /// </summary>
        [AttributeUsage(AttributeTargets.Property)]
        public sealed class LoopListAttribute : Attribute;
        """;

    public const string OptionalSegmentFooterAttribute =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        namespace EdiSource.Domain.SourceGeneration;

        /// <summary>
        ///     With a loop with the LoopGenerator attribute,
        ///     mark a segment footer with this attribute to enable source generation.
        ///     When the loop constructor finds this element, it will break out the loop.
        /// </summary>
        [AttributeUsage(AttributeTargets.Property)]
        public sealed class OptionalSegmentFooterAttribute : Attribute;
        """;

    public const string SegmentAttribute =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        namespace EdiSource.Domain.SourceGeneration;

        /// <summary>
        ///     With a loop with the LoopGenerator attribute,
        ///     mark a segment with this attribute to enable source generation
        /// </summary>
        [AttributeUsage(AttributeTargets.Property)]
        public sealed class SegmentAttribute : Attribute;
        """;

    public const string SegmentFooterAttribute =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        namespace EdiSource.Domain.SourceGeneration;

        /// <summary>
        ///     With a loop with the LoopGenerator attribute,
        ///     mark a loop with this attribute to enable source generation.
        ///     A segment footer is required and will be expected at the end.
        ///     For instance, an IEA is the footer of and ISA.
        /// </summary>
        [AttributeUsage(AttributeTargets.Property)]
        public sealed class SegmentFooterAttribute : Attribute;
        """;

    public const string SegmentGeneratorAttributes =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        using EdiSource.Domain.Loop;
        using EdiSource.Domain.Segments;

        namespace EdiSource.Domain.SourceGeneration;
        #pragma warning disable CS9113 // Parameter is unread.

        /// <summary>
        ///     Mark a segment class with this attribute to enable source generation.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class)]
        public sealed class SegmentGenerator<TParent>(params string?[] args) : Attribute
            where TParent : ILoop;

        public sealed class SegmentGenerator<TParent, TBase>(params string[] args) : Attribute
            where TParent : ILoop
            where TBase : Segment;
        """;

    public const string SegmentHeaderAttribute =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        namespace EdiSource.Domain.SourceGeneration;

        /// <summary>
        ///     With a loop with the LoopGenerator attribute,
        ///     mark a segment header with this attribute to enable source generation.
        ///     A segment header is required and is expected to begin a loop.
        /// </summary>
        [AttributeUsage(AttributeTargets.Property)]
        public sealed class SegmentHeaderAttribute : Attribute;
        """;

    public const string SegmentListAttribute =
        """
        // <auto-generated/>
        #nullable enable
        #pragma warning disable CS0162 // Unreachable code
        #pragma warning disable CS0164 // Unreferenced label
        #pragma warning disable CS0219 // Variable assigned but never used
        #pragma warning disable CS9113 // Parameter is unread.

        namespace EdiSource.Domain.SourceGeneration;

        /// <summary>
        ///     With a loop with the LoopGenerator attribute,
        ///     mark a segment list with this attribute to enable source generation
        /// </summary>
        [AttributeUsage(AttributeTargets.Property)]
        public sealed class SegmentListAttribute : Attribute;
        """;
}

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/Data/LoopMeta.cs
================
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EdiSource.Generator.LoopGen.Data;

public record struct LoopMeta(
    ClassDeclarationSyntax ClassDeclarationSyntax,
    string Parent,
    string Self,
    string Id,
    bool IsTransactionSet);

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/GeneratorWithAttributeHelper.cs
================
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;

namespace EdiSource.Generator.LoopGen;

public static class GeneratorWithAttributeHelper<T> where T : struct
{
    public static void Initialize(
        IncrementalGeneratorInitializationContext context,
        string attributeMetaDataName,
        Func<SyntaxNode, CancellationToken, bool> predicate,
        Func<GeneratorAttributeSyntaxContext, CancellationToken, T?> transform,
        Action<SourceProductionContext, ImmutableArray<T>> createOutput
    )
    {
        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                attributeMetaDataName,
                predicate,
                transform)
            .Where(x => x.HasValue)
            .Select((t, _) => t!.Value);

        context.RegisterSourceOutput(source.Collect(), createOutput);
    }

    public static bool Predicate(SyntaxNode node, CancellationToken ct, Func<SyntaxNode, CancellationToken, bool> fun)
    {
        return fun(node, ct);
    }

    public static T Transform(GeneratorAttributeSyntaxContext context, CancellationToken ct,
        Func<GeneratorAttributeSyntaxContext, CancellationToken, T> fun)
    {
        return fun(context, ct);
    }

    public static void CreateOutput(SourceProductionContext context, ImmutableArray<T> source,
        Action<SourceProductionContext, ImmutableArray<T>> act)
    {
        act(context, source);
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/LoopGenerator.ChannelConstructorGenerator.cs
================
using System.Collections.Immutable;
using EdiSource.Generator.Helper;
using Microsoft.CodeAnalysis;

namespace EdiSource.Generator.LoopGen;

public partial class LoopGenerator
{
    public static class ChannelConstructorGenerator
    {
        public static string Generate(string className, string namespaceName,
            HashSet<string> usings,
            ImmutableArray<(string Name, string Attribute, IPropertySymbol Property)> orderedEdiItems,
            string parent)
        {
            var cw = new CodeWriter();

            cw.AppendLine("#nullable enable");

            cw.AddUsing("System.Diagnostics.CodeAnalysis");
            cw.AddUsing("System.Threading.Channels");
            foreach (var @using in usings) cw.AddUsing(@using);

            cw.AppendLine();
            using (cw.StartNamespace(namespaceName))
            {
                using (cw.StartClass(className, []))
                {
                    cw.AppendLine("""
                                  [SuppressMessage("CodeQuality", "IDE0060:Remove unused parameter", Justification = "Empty constructor is required")]
                                  """);
                    using (cw.StartConstructor(className))
                    {
                    }

                    cw.AppendLine();

                    using (cw.StartConstructor(className,
                               arguments:
                               [
                                   "ChannelReader<Segment> segmentReader", $"{parent}? parent = null"
                               ]))
                    {
                        cw.AppendLine("var loop = InitializeAsync(segmentReader, parent).GetAwaiter().GetResult();");
                        foreach (var item in orderedEdiItems) cw.AppendLine($"{item.Name} = loop.{item.Name};");
                    }

                    cw.AppendLine();

                    using (cw.AppendBlock(
                               $"public static Task<{className}> InitializeAsync(ChannelReader<Segment> segmentReader, ILoop? parent)"))
                    {
                        using (var _ = cw.AddIf("parent is null"))
                        {
                            cw.AppendLine($"return InitializeAsync(segmentReader, ({parent}?) null);");
                        }

                        cw.AppendLine();

                        using (cw.AddIf($"parent is not {parent} typedParent"))
                        {
                            cw.AppendLine(
                                $"""throw new ArgumentException($"Parent must be of type {parent}");""");
                        }

                        cw.AppendLine();

                        cw.AppendLine("return InitializeAsync(segmentReader, typedParent);");
                    }

                    cw.AppendLine();
                    using (cw.AppendBlock(
                               $"public static async Task<{className}> InitializeAsync(ChannelReader<Segment> segmentReader, {parent}? parent)"))
                    {
                        cw.AppendLine($"var loop = new {className}();");
                        cw.AppendLine();

                        if (className != parent)
                        {
                            cw.AppendLine("loop.Parent = parent;");
                            cw.AppendLine();
                        }

                        var headerItems = orderedEdiItems
                            .Where(x => LoopAggregation.Header.Contains(x.Attribute))
                            .ToImmutableArray();
                        GenerateHeaderOrFooter(className, headerItems, cw);

                        var bodyItems = orderedEdiItems
                            .Where(x => LoopAggregation.Body.Contains(x.Attribute))
                            .ToImmutableArray();
                        if (bodyItems.Length > 0)
                        {
                            cw.AppendLine();
                            GenerateBody(className, bodyItems, cw);
                        }

                        var footerItems = orderedEdiItems
                            .Where(x => LoopAggregation.Footer.Contains(x.Attribute))
                            .ToImmutableArray();

                        if (footerItems.Length > 0)
                        {
                            cw.AppendLine();
                            GenerateHeaderOrFooter(className, footerItems, cw);
                        }

                        cw.AppendLine();
                        cw.AppendLine("return loop;");
                    }
                }
            }

            return cw.ToString();
        }

        private static void GenerateHeaderOrFooter(string className,
            ImmutableArray<(string Name, string Attribute, IPropertySymbol Property)> items, CodeWriter cw)
        {
            foreach (var item in items)
                cw.AppendLine(
                    $"loop.{item.Name} = await SegmentLoopFactory<{item.Property.Type.ToString().Replace("?", "")}, {className}>.CreateAsync(segmentReader, loop);");
        }

        private static void GenerateBody(string className,
            ImmutableArray<(string Name, string Attribute, IPropertySymbol Property)> items, CodeWriter cw)
        {
            using (cw.AddWhile("await segmentReader.WaitToReadAsync()"))
            {
                foreach (var (name, attribute, property) in items)
                {
                    var typeName = ((INamedTypeSymbol)property.Type).TypeArguments is { Length: > 0 } named
                        ? named[0]
                        : property.Type;

                    using var _ =
                        cw.AddIf(
                            $"await ISegmentIdentifier<{typeName.ToString().Replace("?", "")}>.MatchesAsync(segmentReader)");

                    cw.AppendLine(attribute switch
                    {
                        SegmentAttribute or Segment =>
                            $"loop.{name} = await SegmentLoopFactory<{typeName.ToString().Replace("?", "")}, {className}>.CreateAsync(segmentReader, loop);",
                        SegmentListAttribute or SegmentList =>
                            $"loop.{name}.Add(await SegmentLoopFactory<{typeName.ToString().Replace("?", "")}, {className}>.CreateAsync(segmentReader, loop));",
                        LoopAttribute or Loop =>
                            $"loop.{name} = await {typeName.ToString().Replace("?", "")}.InitializeAsync(segmentReader, loop);",
                        LoopListAttribute or LoopList =>
                            $"loop.{name}.Add(await {typeName.ToString().Replace("?", "")}.InitializeAsync(segmentReader, loop));",
                        OptionalSegmentFooter or OptionalSegmentFooterAttribute =>
                            $"loop.{name} = SegmentLoopFactory<{typeName.ToString().Replace("?", "")}, {className}>.Create(segments, this);",
                        _ => string.Empty
                    });

                    cw.AppendLine(attribute is OptionalSegmentFooter or OptionalSegmentFooterAttribute
                        ? "break;"
                        : "continue;");
                }

                cw.AppendLine();
                cw.AppendLine("break;");
            }
        }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/LoopGenerator.cs
================
using System.Collections.Immutable;
using System.Text;
using EdiSource.Generator.LoopGen.Data;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace EdiSource.Generator.LoopGen;

public readonly record struct S(string Name, string Value);

[Generator]
public partial class LoopGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        AddAttribute(context, nameof(LoopSourceGenAttributes.LoopAttribute), LoopSourceGenAttributes.LoopAttribute);
        AddAttribute(context, nameof(LoopSourceGenAttributes.LoopGeneratorAttribute),
            LoopSourceGenAttributes.LoopGeneratorAttribute);
        AddAttribute(context, nameof(LoopSourceGenAttributes.LoopListAttribute),
            LoopSourceGenAttributes.LoopListAttribute);
        AddAttribute(context, nameof(LoopSourceGenAttributes.OptionalSegmentFooterAttribute),
            LoopSourceGenAttributes.OptionalSegmentFooterAttribute);
        AddAttribute(context, nameof(LoopSourceGenAttributes.SegmentAttribute),
            LoopSourceGenAttributes.SegmentAttribute);
        AddAttribute(context, nameof(LoopSourceGenAttributes.SegmentFooterAttribute),
            LoopSourceGenAttributes.SegmentFooterAttribute);
        AddAttribute(context, nameof(LoopSourceGenAttributes.SegmentGeneratorAttributes),
            LoopSourceGenAttributes.SegmentGeneratorAttributes);
        AddAttribute(context, nameof(LoopSourceGenAttributes.SegmentHeaderAttribute),
            LoopSourceGenAttributes.SegmentHeaderAttribute);
        AddAttribute(context, nameof(LoopSourceGenAttributes.SegmentListAttribute),
            LoopSourceGenAttributes.SegmentListAttribute);

        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s, LoopAggregation.LoopGeneratorNames),
                static (ctx, _) => PredicateOnClassAttributes(ctx, LoopAggregation.LoopGeneratorNames));

        var compilationAndClasses
            = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item1, source.Right, spc));
    }

    private static void AddAttribute(IncrementalGeneratorInitializationContext context, string name, string text)
    {
        context.RegisterPostInitializationOutput(x =>
            x.AddSource($"{name}.g.cs",
                SourceText.From(text, Encoding.UTF8)));
    }

    private static void Execute(Compilation compilation, ImmutableArray<LoopMeta> classes,
        SourceProductionContext context)
    {
        foreach (var generatorItem in classes)
        {
            var (classDeclaration, parent, self, id, isTransactionSet) = generatorItem;

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol) continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classSymbol.Name;
            var properties = classSymbol.GetMembers().OfType<IPropertySymbol>();

            var classUsings = GetUsingStatements(classDeclaration)
                .Select(x => x.Name?.ToString())
                .OfType<string>()
                .ToImmutableHashSet();

            HashSet<string> usings = [..classUsings, ..Usings];

            var ediItems = properties
                .Select(property => new { property, attribute = GetEdiAttribute(property) })
                .Where(t => !string.IsNullOrEmpty(t.attribute))
                .Select(t => (t.property.Name.Replace("?", ""), t.attribute.Replace("?", ""), t.property))
                .ToArray();

            var orderedEdiItems = OrderEdiItems(ediItems);

            var ediElementSourceCode = EdiElementGenerator.Generate(className, namespaceName, usings, orderedEdiItems);
            context.AddSource($"{className}.EdiElement.g.cs", SourceText.From(ediElementSourceCode, Encoding.UTF8));

            var implementationCode = ImplementationGenerator.Generate(className, namespaceName, usings, parent, id);
            context.AddSource($"{className}.Implementation.g.cs", SourceText.From(implementationCode, Encoding.UTF8));

            if (isTransactionSet)
            {
                var transactionSetCode = TransactionSetGenerator.Generate(className, namespaceName, usings, id);
                context.AddSource($"{className}.TransactionSet.g.cs",
                    SourceText.From(transactionSetCode, Encoding.UTF8));
            }

            var channelConstructorSourceCode =
                ChannelConstructorGenerator.Generate(className, namespaceName, usings, orderedEdiItems, parent);
            context.AddSource($"{className}.ChannelConstructor.g.cs",
                SourceText.From(channelConstructorSourceCode, Encoding.UTF8));
        }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/LoopGenerator.EdiElementGenerator.cs
================
using System.Collections.Immutable;
using EdiSource.Generator.Helper;
using Microsoft.CodeAnalysis;

namespace EdiSource.Generator.LoopGen;

public partial class LoopGenerator
{
    public static class EdiElementGenerator
    {
        public static string Generate(string className, string namespaceName,
            HashSet<string> usings,
            ImmutableArray<(string Name, string Attribute, IPropertySymbol PropertySymbol)> orderedEdiItems)
        {
            var cw = new CodeWriter();

            cw.AppendLine("#nullable enable");

            foreach (var @using in usings) cw.AddUsing(@using);

            cw.AppendLine();
            using (cw.StartNamespace(namespaceName))
            {
                using (cw.StartClass(className, []))
                {
                    var names = orderedEdiItems.Select(x => x.Name).ToArray();
                    cw.AddCalcProperty("EdiItems", "List<IEdi?>",
                        $$"""new List<IEdi?> { {{string.Join(", ", names)}} }""");
                }
            }

            return cw.ToString();
        }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/LoopGenerator.ImplementationGenerator.cs
================
using EdiSource.Generator.Helper;

namespace EdiSource.Generator.LoopGen;

public partial class LoopGenerator
{
    public static class ImplementationGenerator
    {
        public static string Generate(string className, string namespaceName, HashSet<string> usings,
            string parent, string id)
        {
            var cw = new CodeWriter();

            cw.AppendLine("#nullable enable");

            foreach (var @using in usings) cw.AddUsing(@using);

            cw.AppendLine();
            using (cw.StartNamespace(namespaceName))
            {
                string[] implementations =
                [
                    "ILoop", $"IEdi<{parent}>", $"ISegmentIdentifier<{className}>", $"ISegmentIdentifier<{id}>",
                    $"ILoopInitialize<{parent}, {className}>"
                ];
                using (cw.StartClass(className, implementations))
                {
                    // cw.AppendLine("ILoop? ILoop.Parent => Parent;");

                    cw.AppendLine(className == parent
                        ? $$"""public {{parent}}? Parent => null;"""
                        : $$"""public {{parent}}? Parent { get; set; }""");

                    cw.AppendLine($"public static EdiId EdiId => {id}.EdiId;");
                }
            }

            return cw.ToString();
        }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/LoopGenerator.QueueConstructorGenerator.cs
================
using System.Collections.Immutable;
using EdiSource.Generator.Helper;
using Microsoft.CodeAnalysis;

namespace EdiSource.Generator.LoopGen;

public partial class LoopGenerator
{
    public static class QueueConstructorGenerator
    {
        public static string Generate(string className, string namespaceName,
            HashSet<string> usings,
            ImmutableArray<(string Name, string Attribute, IPropertySymbol Property)> orderedEdiItems,
            string parent)
        {
            var cw = new CodeWriter();

            cw.AppendLine("#nullable enable");

            foreach (var @using in usings) cw.AddUsing(@using);
            cw.AppendLine();

            using (cw.StartNamespace(namespaceName))
            {
                using (cw.StartClass(className, []))
                {
                    cw.AppendLine($"public {className}(IEnumerable<Segment> segments, TransactionSet? parent = null)");
                    cw.AppendLine(": this(new Queue<Segment>(segments), parent)");
                    cw.AppendLine("{}");
                    cw.AppendLine();

                    using (cw.StartConstructor(className,
                               arguments: ["Queue<Segment> segments", $"{parent}? parent = null"]))
                    {
                        if (className != parent)
                        {
                            cw.AppendLine("Parent = parent;");
                            cw.AppendLine();
                        }

                        var headerItems = orderedEdiItems
                            .Where(x => LoopAggregation.Header.Contains(x.Attribute))
                            .ToImmutableArray();
                        GenerateHeaderOrFooter(className, headerItems, cw);

                        var bodyItems = orderedEdiItems
                            .Where(x => LoopAggregation.Body.Contains(x.Attribute))
                            .ToImmutableArray();
                        if (bodyItems.Length > 0)
                        {
                            cw.AppendLine();
                            GenerateBody(className, bodyItems, cw);
                        }

                        var footerItems = orderedEdiItems
                            .Where(x => LoopAggregation.Footer.Contains(x.Attribute))
                            .ToImmutableArray();

                        if (footerItems.Length > 0)
                        {
                            cw.AppendLine();
                            GenerateHeaderOrFooter(className, footerItems, cw);
                        }
                    }
                }
            }

            return cw.ToString();
        }

        private static void GenerateHeaderOrFooter(string className,
            ImmutableArray<(string Name, string Attribute, IPropertySymbol Property)> items, CodeWriter cw)
        {
            foreach (var item in items)
                cw.AppendLine(
                    $"{item.Name} = SegmentLoopFactory<{item.Property.Type}, {className}>.Create(segments, this);");
        }

        private static void GenerateBody(string className,
            ImmutableArray<(string Name, string Attribute, IPropertySymbol Property)> items, CodeWriter cw)
        {
            using (cw.AddWhile("segments.Count > 0"))
            {
                foreach (var (name, attribute, property) in items)
                {
                    var typeName = ((INamedTypeSymbol)property.Type).TypeArguments is { Length: > 0 } named
                        ? named[0]
                        : property.Type;

                    using var _ = cw.AddIf($"ISegmentIdentifier<{typeName}>.Matches(segments)");

                    cw.AppendLine(attribute switch
                    {
                        SegmentAttribute or Segment =>
                            $"{name} = SegmentLoopFactory<{typeName}, {className}>.Create(segments, this);",
                        SegmentListAttribute or SegmentList =>
                            $"{name}.Add(SegmentLoopFactory<{typeName}, {className}>.Create(segments, this));",
                        LoopAttribute or Loop => $"{name} = new {property.Type}(segments, this);",
                        LoopListAttribute or LoopList => $"{name}.Add(new {typeName}(segments, this));",
                        OptionalSegmentFooter or OptionalSegmentFooterAttribute =>
                            $"""
                             {name} = SegmentLoopFactory<{typeName}, {className}>.Create(segments, this);
                             """,
                        _ => string.Empty
                    });

                    cw.AppendLine(attribute is OptionalSegmentFooter or OptionalSegmentFooterAttribute
                        ? "break;"
                        : "continue;");
                }

                cw.AppendLine();
                cw.AppendLine("break;");
            }
        }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/LoopGen/LoopGenerator.TransactionSetGenerator.cs
================
using EdiSource.Generator.Helper;

namespace EdiSource.Generator.LoopGen;

public partial class LoopGenerator
{
    public static class TransactionSetGenerator
    {
        public static string Generate(string className, string namespaceName, HashSet<string> usings, string id)
        {
            var cw = new CodeWriter();

            cw.AppendLine("#nullable enable");

            foreach (var @using in usings) cw.AddUsing(@using);

            cw.AppendLine();
            using (cw.StartNamespace(namespaceName))
            {
                using (cw.StartClass(className, [$"ITransactionSet<{className}, {id}>"]))
                {
                    cw.AppendLine("public static TransactionSetDefinition Definition { get; } = id =>");
                    cw.AppendLine("{");
                    cw.IncreaseIndent();
                    using (cw.AddIf(
                               "EdiId.Primary != id.Item1 || (EdiId.Secondary is not null && EdiId.Secondary != id.Item2)"))
                    {
                        cw.AppendLine("return null;");
                    }

                    cw.AppendLine("return (segmentReader, parent) => InitializeAsync(segmentReader, parent)");
                    cw.IncreaseIndent();
                    cw.AppendLineIndent(".ContinueWith(ILoop (x) => x.Result);");
                    cw.DecreaseIndent();
                    cw.DecreaseIndent();
                    cw.AppendLine("};");
                }
            }

            return cw.ToString();
        }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/Properties/launchSettings.json
================
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "DebugRoslynSourceGenerator": {
      "commandName": "DebugRoslynComponent",
      "targetProject": "../../EdiSource.App/EdiSource.App.csproj"
    }
  }
}

================
File: EdiSource.Generator/EdiSource.Generator/SegmentGen/SegmentGenerator.Generate.cs
================
using System.Collections.Immutable;
using EdiSource.Generator.Helper;

namespace EdiSource.Generator.SegmentGen;

public partial class SegmentGenerator
{
    private static string Generate(string className, string namespaceName, HashSet<string> usings, string parent,
        ImmutableArray<string> args, string? subType)
    {
        var cw = new CodeWriter();

        foreach (var @using in usings) cw.AddUsing(@using);

        cw.AppendLine();
        using (cw.StartNamespace(namespaceName))
        {
            ReadOnlySpan<string> implementations =
                [subType ?? "Segment", $"IEdi<{parent}>", $"ISegmentIdentifier<{className}>"];

            using (cw.StartClass(className, implementations))
            {
                cw.AppendLine(subType is not null
                    ? $"public new {parent}? Parent {{ get; set; }}"
                    : $"public {parent}? Parent {{ get; set; }}");

                cw.AppendLine(
                    $"public static EdiId EdiId => new ({string.Join(", ", args)});");
            }
        }

        return cw.ToString();
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/SegmentGen/SegmentsGenerator.cs
================
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace EdiSource.Generator.SegmentGen;

[Generator]
public partial class SegmentGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s, LoopAggregation.SegmentGeneratorNames),
                static (ctx, _) => PredicateOnClassAttributesClassParent(ctx, LoopAggregation.SegmentGeneratorNames));

        var compilationAndClasses
            = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item1, source.Right, spc));
    }

    private static void Execute(Compilation compilation,
        ImmutableArray<(ClassDeclarationSyntax, string loop, ImmutableArray<string> args, string? subType)>
            classes,
        SourceProductionContext context)
    {
        foreach (var (classDeclaration, parent, args, subType) in classes)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol) continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classSymbol.Name;

            var classUsings = GetUsingStatements(classDeclaration)
                .Select(x => x.Name?.ToString())
                .OfType<string>()
                .ToImmutableArray();

            var implementationCode =
                Generate(className, namespaceName, [..classUsings, ..Usings], parent, args, subType);
            context.AddSource($"{className}.Implementation.g.cs", SourceText.From(implementationCode, Encoding.UTF8));
        }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/ValidationGen/ValidationGenerator.cs
================
using System.Collections.Immutable;
using System.Text;
using EdiSource.Generator.Helper;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using CSharpExtensions = Microsoft.CodeAnalysis.CSharp.CSharpExtensions;

namespace EdiSource.Generator.ValidationGen;

[Generator(LanguageNames.CSharp)]
public class ValidationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<ValidationContext> classDeclarations =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (s, _) => IsSyntaxTargetForGeneration(s),
                    static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null)!;

        IncrementalValueProvider<(Compilation, ImmutableArray<ValidationContext>)> compilationAndClasses
            = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static ValidationContext? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        var target = classDeclarationSyntax
            .AttributeLists
            .SelectMany(attributeList => attributeList.Attributes,
                (_, attribute) => CSharpExtensions.GetTypeInfo(context.SemanticModel, attribute))
            .Select(attributeSymbol => new
            {
                TypeSymbol = attributeSymbol, Definition = attributeSymbol.Type?.OriginalDefinition.ToDisplayString()
            })
            .FirstOrDefault(x =>
                x.Definition is "EdiSource.Domain.SourceGeneration.LoopGeneratorAttribute<TParent, TSelf, TId>");

        if (target is not null)
            return new ValidationContext
            {
                ClassDeclarationSyntax = classDeclarationSyntax,
                SubType = GetSegmentGeneratorSubType(context)
            };

        return null;
    }

    private static bool IsTargetAttribute(string attributeName)
    {
        return attributeName switch
        {
            "ElementLength" or "ElementLengthAttribute" or
                "Empty" or "EmptyAttribute" or
                "IsOneOfValues" or "IsOneOfValuesAttribute" or
                "NotEmpty" or "NotEmptyAttribute" or
                "NotOneOfValues" or "NotOneOfValuesAttribute" or
                "RequiredDataElements" or "RequiredDataElementsAttribute" or
                "RequireElement" or "RequiredElementAttribute" or
                "BeDate" or "SegmentElementLengthAttribute" or
                "BeDateTime" or "BeDateTimeAttribute" or
                "BeTime" or "BeTimeAttribute" or
                "BeInt" or "BeIntAttribute" or
                "BeDecimal" or "BeDecimalAttribute" or
                "CompositeElementLength" or "CompositeElementLengthAttribute" => true,
            _ => false
        };
    }

    private static void Execute(Compilation compilation, ImmutableArray<ValidationContext> classes,
        SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty) return;

        foreach (var it in classes)
        {
            var (classDeclaration, subType) = (it.ClassDeclarationSyntax, it.SubType);

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

            if (classSymbol == null) continue;

            CodeWriter cw = new();

            var sgv =
                compilation.GetTypeByMetadataName("EdiSource.Domain.Validation.Data.ISourceGeneratorValidatable");
            if (sgv == null)
                continue;

            using (cw.StartNamespace(classSymbol.ContainingNamespace.ToDisplayString()))
            {
                foreach (var @using in Usings)
                    cw.AddUsing(@using);

                using (cw.StartClass(classDeclaration.Identifier.Text, ["ISourceGeneratorValidatable"]))
                {
                    cw.AppendLine(subType == null
                        ? "public List<IIndirectValidatable> SourceGenValidations => ["
                        : "new public List<IIndirectValidatable> SourceGenValidations => [");

                    cw.IncreaseIndent();
                    if (subType != null) cw.AppendLine("..base.SourceGenValidations, ");

                    ProcessAttributes(classDeclaration, cw, semanticModel);
                    cw.DecreaseIndent();
                    cw.AppendLine("];");
                }
            }

            context.AddSource($"{classSymbol.Name}.Validation.g.cs", SourceText.From(cw.ToString(), Encoding.UTF8));
        }
    }

    private static void ProcessAttributes(ClassDeclarationSyntax classDeclarationSyntax, CodeWriter cw,
        SemanticModel model)
    {
        foreach (var attributeList in classDeclarationSyntax.AttributeLists)
        foreach (var attribute in attributeList.Attributes)
        {
            var attributeName = attribute.Name.ToString();

            if (!IsTargetAttribute(attributeName)) continue;

            cw.Append("new ");
            cw.Append(attributeName);
            if (!attributeName.EndsWith("Attribute")) cw.Append("Attribute");

            cw.Append("(");
            cw.Append(attribute.ArgumentList?.Arguments.ToString() ?? string.Empty);
            cw.AppendLine("),");
        }
    }

    private sealed class ValidationContext
    {
        public required ClassDeclarationSyntax ClassDeclarationSyntax { get; set; }
        public required TypeSyntax? SubType { get; set; }
    }
}

================
File: EdiSource.Generator/EdiSource.Generator/EdiSource.Generator.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>netstandard2.0</TargetFramework>
        <IsPackable>false</IsPackable>
        <Nullable>enable</Nullable>
        <LangVersion>latest</LangVersion>
        <ImplicitUsings>true</ImplicitUsings>

        <EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
        <IsRoslynComponent>true</IsRoslynComponent>

        <WarningsAsErrors>true</WarningsAsErrors>

        <RootNamespace>EdiSource.Generator</RootNamespace>
        <PackageId>EdiSource.Generator</PackageId>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.11.0">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.11.0"/>
        <!--        <PackageReference Include="Microsoft.CodeAnalysis.CSharp.Workspaces" Version="4.11.0"/>-->
        <PackageReference Include="PolySharp" Version="1.14.1">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>
</Project>

================
File: EdiSource.Generator/EdiSource.Generator/GlobalUsings.cs
================
global using static EdiSource.Generator.Helper.Constants;
global using static EdiSource.Generator.Helper.HelperFunctions;

================
File: SourceGenerators1/EdiSource.Generator.Tests/LoopGenerator/LoopGeneratorTests.cs
================
using System.Threading.Tasks;
using EdiSource.Generator.Tests.Utils;
using VerifyXunit;
using Xunit;

namespace EdiSource.Generator.Tests.LoopGenerator;

public class LoopGeneratorTests
{
    private const string Source =
        """
        namespace Test;

        [LoopGenerator<TransactionSet, TransactionSet, TS_ST>]
        public partial class TransactionSet
        {
            [SegmentHeader] public TS_ST ST { get; set; } = default!;
        
            [SegmentList] public SegmentList<TS_REF> REFs { get; set; } = [];
        
            [Segment] public TS_DTP DTP { get; set; }
        
            [Loop] public Loop2000 Loop2000 { get; set; }
        
            [LoopList] public LoopList<Loop2100> Loop2100s { get; set; } = [];
        
            [OptionalSegmentFooter] public TS_FSE SE { get; set; }
        
            [SegmentFooter] public TS_SE SE { get; set; }
        }
        """;

    private const string Source2 =
        """
        namespace Test;

        [LoopGenerator<TransactionSet, TransactionSet, TS_ST>(true)]
        public partial class TransactionSet
        {
            [SegmentHeader] public TS_ST ST { get; set; } = default!;
        
            [SegmentList] public SegmentList<TS_REF> REFs { get; set; } = [];
        
            [Segment] public TS_DTP DTP { get; set; }
        
            [Loop] public Loop2000 Loop2000 { get; set; }
        
            [LoopList] public LoopList<Loop2100> Loop2100s { get; set; } = [];
        
            [OptionalSegmentFooter] public TS_FSE SE { get; set; }
        
            [SegmentFooter] public TS_SE SE { get; set; }
        }
        """;

    [Fact]
    public Task TestA()
    {
        var driver = TestHelperFunctions.Verify<LoopGen.LoopGenerator>(Source);
        return Verifier.Verify(driver, TestHelperFunctions.Settings.Value);
    }

    [Fact]
    public Task IsTranscationSet()
    {
        var driver = TestHelperFunctions.Verify<LoopGen.LoopGenerator>(Source2);
        return Verifier.Verify(driver, TestHelperFunctions.Settings.Value);
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/LoopGenerator/LoopGeneratorTests.IsTranscationSet#TransactionSet.ChannelConstructor.g.verified.cs
================
//HintName: TransactionSet.ChannelConstructor.g.cs
#nullable enable
using System.Diagnostics.CodeAnalysis;
using System.Threading.Channels;
using EdiSource.Domain.Separator;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using System.Linq;
using System.Collections.Generic;
using System;

namespace Test
{
    public partial class TransactionSet
    {
        [SuppressMessage("CodeQuality", "IDE0060:Remove unused parameter", Justification = "Empty constructor is required")]
        public TransactionSet()
        {
        }

        public TransactionSet(ChannelReader<ISegment> segmentReader, TransactionSet? parent = null)
        {
            var loop = InitializeAsync(segmentReader, parent).GetAwaiter().GetResult();
            ST = loop.ST;
            DTP = loop.DTP;
            REFs = loop.REFs;
            Loop2000 = loop.Loop2000;
            Loop2100s = loop.Loop2100s;
            SE = loop.SE;
            SE = loop.SE;
        }

        public static Task<TransactionSet> InitializeAsync(ChannelReader<ISegment> segmentReader, ILoop? parent)
        {
            if (parent is null)
            {
                return InitializeAsync(segmentReader, (TransactionSet? )null);
            }

            if (parent is not TransactionSet typedParent)
            {
                throw new ArgumentException($"Parent must be of type TransactionSet");
            }

            return InitializeAsync(segmentReader, typedParent);
        }

        public static async Task<TransactionSet> InitializeAsync(ChannelReader<ISegment> segmentReader, TransactionSet? parent)
        {
            var loop = new TransactionSet();
            loop.ST = await SegmentLoopFactory<TS_ST, TransactionSet>.CreateAsync(segmentReader, loop);
            while (await segmentReader.WaitToReadAsync())
            {
                if (await ISegmentIdentifier<TS_DTP>.MatchesAsync(segmentReader))
                {
                    loop.DTP = await SegmentLoopFactory<TS_DTP, TransactionSet>.CreateAsync(segmentReader, loop);
                    continue;
                }

                if (await ISegmentIdentifier<TS_REF>.MatchesAsync(segmentReader))
                {
                    loop.REFs.Add(await SegmentLoopFactory<TS_REF, TransactionSet>.CreateAsync(segmentReader, loop));
                    continue;
                }

                if (await ISegmentIdentifier<Loop2000>.MatchesAsync(segmentReader))
                {
                    loop.Loop2000 = await Loop2000.InitializeAsync(segmentReader, loop);
                    continue;
                }

                if (await ISegmentIdentifier<Loop2100>.MatchesAsync(segmentReader))
                {
                    loop.Loop2100s.Add(await Loop2100.InitializeAsync(segmentReader, loop));
                    continue;
                }

                if (await ISegmentIdentifier<TS_FSE>.MatchesAsync(segmentReader))
                {
                    loop.SE = SegmentLoopFactory<TS_FSE, TransactionSet>.Create(segments, this);
                    break;
                }

                break;
            }

            loop.SE = await SegmentLoopFactory<TS_SE, TransactionSet>.CreateAsync(segmentReader, loop);
            return loop;
        }
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/LoopGenerator/LoopGeneratorTests.IsTranscationSet#TransactionSet.EdiElement.g.verified.cs
================
//HintName: TransactionSet.EdiElement.g.cs
#nullable enable
using EdiSource.Domain.Separator;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using System.Linq;
using System.Collections.Generic;
using System;

namespace Test
{
    public partial class TransactionSet
    {
        public List<IEdi?> EdiItems => new List<IEdi?>
        {
            ST,
            DTP,
            REFs,
            Loop2000,
            Loop2100s,
            SE,
            SE
        };
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/LoopGenerator/LoopGeneratorTests.IsTranscationSet#TransactionSet.Implementation.g.verified.cs
================
//HintName: TransactionSet.Implementation.g.cs
#nullable enable
using EdiSource.Domain.Separator;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using System.Linq;
using System.Collections.Generic;
using System;

namespace Test
{
    public partial class TransactionSet : ILoop, ILoop<TransactionSet>, ISegmentIdentifier<TransactionSet>, ISegmentIdentifier<TS_ST>, ILoopInitialize<TransactionSet, TransactionSet>
    {
        ILoop? ILoop.Parent => Parent;
        public TransactionSet? Parent => null;
        public static (string Primary, string? Secondary) EdiId => TS_ST.EdiId;
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/LoopGenerator/LoopGeneratorTests.IsTranscationSet#TransactionSet.TransactionSet.g.verified.cs
================
//HintName: TransactionSet.TransactionSet.g.cs
#nullable enable
using EdiSource.Domain.Separator;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using System.Linq;
using System.Collections.Generic;
using System;

namespace Test
{
    public partial class TransactionSet : ITransactionSet<TransactionSet, TS_ST>
    {
        ISegment ITransactionSet.ST => ST;

        ISegment ITransactionSet.SE => SE;
        public static TransactionSetDefinition Definition { get; } = id =>
        {
            if (EdiId.Primary != id.Item1 || (EdiId.Secondary is not null && EdiId.Secondary != id.Item2))
            {
                return null;
            }

            return (segmentReader, parent) => InitializeAsync(segmentReader, parent).ContinueWith(ILoop (x) => x.Result);
        };
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/LoopGenerator/LoopGeneratorTests.TestA#TransactionSet.ChannelConstructor.g.verified.cs
================
//HintName: TransactionSet.ChannelConstructor.g.cs
#nullable enable
using System.Diagnostics.CodeAnalysis;
using System.Threading.Channels;
using EdiSource.Domain.Separator;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using System.Linq;
using System.Collections.Generic;
using System;

namespace Test
{
    public partial class TransactionSet
    {
        [SuppressMessage("CodeQuality", "IDE0060:Remove unused parameter", Justification = "Empty constructor is required")]
        public TransactionSet()
        {
        }

        public TransactionSet(ChannelReader<ISegment> segmentReader, TransactionSet? parent = null)
        {
            var loop = InitializeAsync(segmentReader, parent).GetAwaiter().GetResult();
            ST = loop.ST;
            DTP = loop.DTP;
            REFs = loop.REFs;
            Loop2000 = loop.Loop2000;
            Loop2100s = loop.Loop2100s;
            SE = loop.SE;
            SE = loop.SE;
        }

        public static Task<TransactionSet> InitializeAsync(ChannelReader<ISegment> segmentReader, ILoop? parent)
        {
            if (parent is null)
            {
                return InitializeAsync(segmentReader, (TransactionSet? )null);
            }

            if (parent is not TransactionSet typedParent)
            {
                throw new ArgumentException($"Parent must be of type TransactionSet");
            }

            return InitializeAsync(segmentReader, typedParent);
        }

        public static async Task<TransactionSet> InitializeAsync(ChannelReader<ISegment> segmentReader, TransactionSet? parent)
        {
            var loop = new TransactionSet();
            loop.ST = await SegmentLoopFactory<TS_ST, TransactionSet>.CreateAsync(segmentReader, loop);
            while (await segmentReader.WaitToReadAsync())
            {
                if (await ISegmentIdentifier<TS_DTP>.MatchesAsync(segmentReader))
                {
                    loop.DTP = await SegmentLoopFactory<TS_DTP, TransactionSet>.CreateAsync(segmentReader, loop);
                    continue;
                }

                if (await ISegmentIdentifier<TS_REF>.MatchesAsync(segmentReader))
                {
                    loop.REFs.Add(await SegmentLoopFactory<TS_REF, TransactionSet>.CreateAsync(segmentReader, loop));
                    continue;
                }

                if (await ISegmentIdentifier<Loop2000>.MatchesAsync(segmentReader))
                {
                    loop.Loop2000 = await Loop2000.InitializeAsync(segmentReader, loop);
                    continue;
                }

                if (await ISegmentIdentifier<Loop2100>.MatchesAsync(segmentReader))
                {
                    loop.Loop2100s.Add(await Loop2100.InitializeAsync(segmentReader, loop));
                    continue;
                }

                if (await ISegmentIdentifier<TS_FSE>.MatchesAsync(segmentReader))
                {
                    loop.SE = SegmentLoopFactory<TS_FSE, TransactionSet>.Create(segments, this);
                    break;
                }

                break;
            }

            loop.SE = await SegmentLoopFactory<TS_SE, TransactionSet>.CreateAsync(segmentReader, loop);
            return loop;
        }
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/LoopGenerator/LoopGeneratorTests.TestA#TransactionSet.EdiElement.g.verified.cs
================
//HintName: TransactionSet.EdiElement.g.cs
#nullable enable
using EdiSource.Domain.Separator;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using System.Linq;
using System.Collections.Generic;
using System;

namespace Test
{
    public partial class TransactionSet
    {
        public List<IEdi?> EdiItems => new List<IEdi?>
        {
            ST,
            DTP,
            REFs,
            Loop2000,
            Loop2100s,
            SE,
            SE
        };
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/LoopGenerator/LoopGeneratorTests.TestA#TransactionSet.Implementation.g.verified.cs
================
//HintName: TransactionSet.Implementation.g.cs
#nullable enable
using EdiSource.Domain.Separator;
using EdiSource.Domain.Segments;
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Validation.SourceGeneration;
using EdiSource.Domain.Validation.Data;
using System.Linq;
using System.Collections.Generic;
using System;

namespace Test
{
    public partial class TransactionSet : ILoop, ILoop<TransactionSet>, ISegmentIdentifier<TransactionSet>, ISegmentIdentifier<TS_ST>, ILoopInitialize<TransactionSet, TransactionSet>
    {
        ILoop? ILoop.Parent => Parent;
        public TransactionSet? Parent => null;
        public static (string Primary, string? Secondary) EdiId => TS_ST.EdiId;
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/SegmentGenerator/SegmentGeneratorTests.cs
================
using System.Threading.Tasks;
using EdiSource.Generator.Tests.Utils;
using VerifyXunit;
using Xunit;

namespace EdiSource.Generator.Tests.SegmentGenerator;

public class SegmentGeneratorTests
{
    private const string Source =
        """
        using EdiSource.Domain.Identifiers;
        using EdiSource.Domain.Loop;
        using EdiSource.Domain.Segments;
        using EdiSource.Domain.SourceGeneration;
        using EdiSource.Segments;

        namespace EdiSource.Loops;

        [SegmentGenerator<Test>("INS", null)]
        public class Test_INS : Segment, ISegment<Test>, ISegmentIdentifier<Test_INS>
        {
            public Test? Parent { get; }
            public static (string Primary, string? Secondary) EdiId => ("INS", null);
        }
        """;

    [Fact]
    public Task TestA()
    {
        var driver = TestHelperFunctions.Verify<SegmentGen.SegmentGenerator>(Source);
        return Verifier.Verify(driver);
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/SegmentGenerator/SegmentGeneratorTests.TestA#Test_INS.Implementation.g.verified.cs
================
//HintName: Test_INS.Implementation.g.cs
#nullable enable
using EdiSource.Domain.Identifiers;
using EdiSource.Domain.Loop;
using EdiSource.Domain.Segments;
using EdiSource.Domain.SourceGeneration;
using EdiSource.Segments;
using EdiSource.Domain.Separator;
using EdiSource.Loops;
using System.Linq;
using System.Collections.Generic;
using System;

namespace EdiSource.Loops
{
    public partial class Test_INS
    : Segment, ISegment<Test>, ISegmentIdentifier<Test_INS>
    {
        new public Test? Parent { get; set; }
        public static (string Primary, string? Secondary) EdiId => ("INS", null);
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/Utils/ModuleInitializer.cs
================
using System.Runtime.CompilerServices;
using VerifyTests;

namespace EdiSource.Generator.Tests.Utils;

public static class ModuleInitializer
{
    [ModuleInitializer]
    public static void Init()
    {
        VerifyDiffPlex.Initialize();
        VerifySourceGenerators.Initialize();
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/Utils/TestHelperFunctions.cs
================
using System;
using EdiSource.Domain.Identifiers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using VerifyTests;

namespace EdiSource.Generator.Tests.Utils;

public static class TestHelperFunctions
{
    public static readonly Lazy<VerifySettings> Settings = new(() =>
    {
        var settings = new VerifySettings();

        settings.DisableDiff();

        return settings;
    });

    public static GeneratorDriver Verify<T>(string source) where T : IIncrementalGenerator, new()
    {
        var generator = new T();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        var compilation = CSharpCompilation.Create(nameof(T),
            [CSharpSyntaxTree.ParseText(source)],
            [
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Attribute).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(IEdi).Assembly.Location)
            ]);

        return driver.RunGenerators(compilation);
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/ValidationTests/ValidationGeneratorTests.cs
================
using System.Threading.Tasks;
using EdiSource.Generator.Tests.Utils;
using EdiSource.Generator.ValidationGen;
using VerifyXunit;
using Xunit;

namespace EdiSource.Generator.Tests.ValidationTests;

public sealed class ValidationGeneratorTests
{
    private const string Source =
        """
        using EdiSource.Domain.SourceGeneration;
        using EdiSource.Domain.Validation.Data;
        using EdiSource.Domain.Validation.Factory;
        using EdiSource.Domain.Validation.SourceGeneration;
        using EdiSource.Loops;

        namespace EdiSource.Segments;

        [ElementLength(0, 1, 3, 3)]
        public partial class TS_SE
        {
        }
        """;

    [Fact]
    public Task TestA()
    {
        var driver = TestHelperFunctions.Verify<ValidationGenerator>(Source);
        return Verifier.Verify(driver);
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/ValidationTests/ValidationGeneratorTests.TestA#TS_SE.Validation.g.received.cs
================
//HintName: TS_SE.Validation.g.cs
namespace EdiSource.Segments
{
    using EdiSource.Domain.Separator;
    using EdiSource.Domain.Segments;
    using EdiSource.Domain.Identifiers;
    using EdiSource.Domain.SourceGeneration;
    using EdiSource.Domain.Loop;
    using EdiSource.Domain.Validation.SourceGeneration;
    using EdiSource.Domain.Validation.Data;
    using System.Linq;
    using System.Collections.Generic;
    using System;

    public partial class TS_SE : ISourceGeneratorValidatable
    {
        public List<IIndirectValidatable> SourceGenValidations => [new ElementLengthAttribute(0, 1, 3, 3), ];
    }
}

================
File: SourceGenerators1/EdiSource.Generator.Tests/EdiSource.Generator.Tests.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>

        <IsPackable>false</IsPackable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="coverlet.collector" Version="6.0.2"/>
        <PackageReference Include="Verify.XUnit" Version="26.6.0"/>
        <PackageReference Include="Verify.SourceGenerators" Version="2.5.0"/>
        <PackageReference Include="Verify.DiffPlex" Version="*"/>
        <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.11.0" PrivateAssets="all"/>
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.11.0" PrivateAssets="all"/>
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp.SourceGenerators.Testing.XUnit" Version="1.1.2"/>
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.1"/>
        <PackageReference Include="xunit" Version="2.9.2"/>
        <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\EdiSource.Domain\EdiSource.Domain.csproj"/>
        <ProjectReference Include="..\..\EdiSource.Generator\EdiSource.Generator\EdiSource.Generator.csproj"/>
    </ItemGroup>

    <ItemGroup>
        <None Remove="SegmentGenerator\SegmentGeneratorTests.TestA#Test_INS.Implementation.g.received.cs"/>
    </ItemGroup>
</Project>

================
File: .gitignore
================
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

.idea

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml

================
File: .repopackignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: EdiSource.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EdiSource.App", "EdiSource.App\EdiSource.App.csproj", "{66440C03-89CD-4E3F-B4C8-5DA339270924}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EdiSource.Domain", "EdiSource.Domain\EdiSource.Domain.csproj", "{32968A93-4806-4596-9115-804CA34D0598}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EdiSource.Generator", "EdiSource.Generator\EdiSource.Generator\EdiSource.Generator.csproj", "{F3C797A1-563B-4CE4-93AC-69468FBBFE35}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EdiSource.Generator.Tests", "SourceGenerators1\EdiSource.Generator.Tests\EdiSource.Generator.Tests.csproj", "{C2C91417-CBC3-4EB8-BE60-EA680437263A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EdiSource.Domain.Tests", "EdiSource.Domain.Tests\EdiSource.Domain.Tests.csproj", "{B9714AB2-33F4-4E2E-8ED4-F500018B5184}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "SolutionItems", "SolutionItems", "{BA975AEA-2B12-4956-BD34-FB15EAAB34E8}"
	ProjectSection(SolutionItems) = preProject
		EdiSource.sln.DotSettings.user = EdiSource.sln.DotSettings.user
		repopack.config.json = repopack.config.json
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{66440C03-89CD-4E3F-B4C8-5DA339270924}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{66440C03-89CD-4E3F-B4C8-5DA339270924}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{66440C03-89CD-4E3F-B4C8-5DA339270924}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{66440C03-89CD-4E3F-B4C8-5DA339270924}.Release|Any CPU.Build.0 = Release|Any CPU
		{32968A93-4806-4596-9115-804CA34D0598}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{32968A93-4806-4596-9115-804CA34D0598}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{32968A93-4806-4596-9115-804CA34D0598}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{32968A93-4806-4596-9115-804CA34D0598}.Release|Any CPU.Build.0 = Release|Any CPU
		{F3C797A1-563B-4CE4-93AC-69468FBBFE35}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F3C797A1-563B-4CE4-93AC-69468FBBFE35}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F3C797A1-563B-4CE4-93AC-69468FBBFE35}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F3C797A1-563B-4CE4-93AC-69468FBBFE35}.Release|Any CPU.Build.0 = Release|Any CPU
		{C2C91417-CBC3-4EB8-BE60-EA680437263A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C2C91417-CBC3-4EB8-BE60-EA680437263A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C2C91417-CBC3-4EB8-BE60-EA680437263A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C2C91417-CBC3-4EB8-BE60-EA680437263A}.Release|Any CPU.Build.0 = Release|Any CPU
		{B9714AB2-33F4-4E2E-8ED4-F500018B5184}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B9714AB2-33F4-4E2E-8ED4-F500018B5184}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B9714AB2-33F4-4E2E-8ED4-F500018B5184}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B9714AB2-33F4-4E2E-8ED4-F500018B5184}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal

================
File: repopack.config.json
================
{
  "output": {
    "filePath": "repopack-output.txt",
    "style": "plain",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  }
}
